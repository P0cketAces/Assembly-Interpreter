<?xml version="1.0"?><st-source><component-created><name>AssemblyInterpreter</name> <type>package</type></component-created><class><name>ALI</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AssemblyInterpreter</package></attributes></class><methods><class-id>ALI</class-id> <category>initialize-release</category><body package="AssemblyInterpreter" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>ALI class</class-id> <category>instance creation</category><body package="AssemblyInterpreter" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><do-it>ALI class organization addCategory: #Memory</do-it><do-it>ALI asNameSpace organization addCategory: #Memory</do-it><do-it>ALI asNameSpace organization addCategory: #RegA</do-it><do-it>ALI asNameSpace organization addCategory: #RegB</do-it><do-it>ALI asNameSpace organization addCategory: #PC</do-it><do-it>ALI class organization removeCategory: #Memory</do-it><component-created><name>CS474</name> <type>package</type></component-created><class><name>NewDictionary</name><environment>Smalltalk</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><class><name>TreeDictionary</name><environment>Smalltalk</environment><super>NewDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bst </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><class><name>BST</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>root </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><class><name>DictionaryPair</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>key value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><class><name>SortedDictionary</name><environment>Smalltalk</environment><super>NewDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars>items </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><class><name>TreeDictionaryNode</name><environment>Smalltalk</environment><super>DictionaryPair</super><private>false</private><indexed-type>none</indexed-type><inst-vars>left right </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><class><name>NewDictionaryGUI</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary keyToAdd valueResult keyToGet valueToAdd itemsList doMethod </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><methods><class-id>BST class</class-id> <category>instance creation</category><body package="CS474" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>BST</class-id> <category>accessing</category><body package="CS474" selector="get:">get: aNode	| tempNode |	(root isNil)		ifTrue: [^nil].	tempNode := root.	[tempNode notNil]		whileTrue: [ (tempNode key = (aNode key))					ifTrue: [^tempNode].				    (tempNode key &gt; (aNode key))					ifTrue: [ (tempNode left isNil)						ifTrue: [^nil]						ifFalse: [tempNode := tempNode left]]					ifFalse: [ (tempNode right isNil)						ifTrue: [^nil]						ifFalse: [tempNode := tempNode right]].				].	^nil</body></methods><methods><class-id>BST</class-id> <category>accessing</category><body package="CS474" selector="insert:">insert: aNode	| tempNode |	(root isNil)		ifTrue: [root := aNode.			^self].	tempNode := root.	[tempNode notNil]		whileTrue: [ (tempNode key = (aNode key))					ifTrue: [tempNode value: (aNode value). ^self].				    (tempNode key &gt; (aNode key))					ifTrue: [ (tempNode left isNil)						ifTrue: [tempNode left: aNode. ^self]						ifFalse: [tempNode := tempNode left]]					ifFalse: [ (tempNode right isNil)						ifTrue: [tempNode right: aNode. ^self]						ifFalse: [tempNode := tempNode right]].				].	^self</body></methods><methods><class-id>BST</class-id> <category>accessing</category><body package="CS474" selector="root:">root: anObject	root := anObject</body></methods><methods><class-id>BST</class-id> <category>accessing</category><body package="CS474" selector="root">root	^root</body></methods><methods><class-id>BST</class-id> <category>accessing</category><body package="CS474" selector="allNodes">allNodes	| allNodes tempNode traversal|	allNodes := SortedCollection new initialize.	allNodes sortBlock: [:a :b | (a key) &lt;= (b key)].	(root isNil)		ifTrue: [^allNodes].	tempNode := root.	traversal := OrderedCollection new initialize.	traversal add: tempNode.	[traversal notEmpty]		whileTrue: [ | firstNode |			firstNode := traversal removeFirst.			allNodes add: firstNode.			(firstNode left notNil)				ifTrue: [traversal add: (firstNode left)].			(firstNode right notNil)				ifTrue: [traversal add: (firstNode right)]			].		^allNodes</body></methods><methods><class-id>BST</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	root := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>DictionaryPair class</class-id> <category>instance creation</category><body package="CS474" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>DictionaryPair</class-id> <category>accessing</category><body package="CS474" selector="key:">key: anObject	key := anObject</body></methods><methods><class-id>DictionaryPair</class-id> <category>accessing</category><body package="CS474" selector="key">key	^key</body></methods><methods><class-id>DictionaryPair</class-id> <category>accessing</category><body package="CS474" selector="value:">value: anObject	value := anObject</body></methods><methods><class-id>DictionaryPair</class-id> <category>accessing</category><body package="CS474" selector="value">value	^value</body></methods><methods><class-id>DictionaryPair</class-id> <category>printing</category><body package="CS474" selector="printOn:">printOn: aStream	aStream nextPutAll: key.	aStream nextPutAll: ' -&gt; '.	aStream print: value</body></methods><methods><class-id>DictionaryPair</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	key := nil.	value := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>TreeDictionaryNode</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	left := nil.	right := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>TreeDictionaryNode</class-id> <category>accessing</category><body package="CS474" selector="right:">right: anObject	right := anObject</body></methods><methods><class-id>TreeDictionaryNode</class-id> <category>accessing</category><body package="CS474" selector="left">left	^left</body></methods><methods><class-id>TreeDictionaryNode</class-id> <category>accessing</category><body package="CS474" selector="left:">left: anObject	left := anObject</body></methods><methods><class-id>TreeDictionaryNode</class-id> <category>accessing</category><body package="CS474" selector="right">right	^right</body></methods><methods><class-id>NewDictionary class</class-id> <category>instance creation</category><body package="CS474" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>NewDictionary</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>NewDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: key put: value	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "	^self subclassResponsibility</body></methods><methods><class-id>NewDictionary</class-id> <category>accessing</category><body package="CS474" selector="allPairs">allPairs	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "	| allKeys allValues pairs|	allKeys := self keys.	allValues := self values.	pairs := OrderedCollection new initialize.	1 to: allKeys size		do: [ :index | | temp |			temp := DictionaryPair new initialize.			temp key: (allKeys at: index).			temp value: (allValues at: index).			pairs add: temp].	^pairs</body></methods><methods><class-id>NewDictionary</class-id> <category>accessing</category><body package="CS474" selector="keys">keys	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "	^self subclassResponsibility</body></methods><methods><class-id>NewDictionary</class-id> <category>accessing</category><body package="CS474" selector="values">values	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "	^self subclassResponsibility</body></methods><methods><class-id>NewDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:">at: key	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "	^self subclassResponsibility</body></methods><methods><class-id>NewDictionary</class-id> <category>removing</category><body package="CS474" selector="remove:ifAbsent:">remove: oldObject ifAbsent: anExceptionBlock	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "	^self shouldNotImplement</body></methods><methods><class-id>NewDictionary</class-id> <category>adding</category><body package="CS474" selector="add:">add: newObject	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "	| ret |	( (self at: (newObject key)) isNil)		ifTrue: [ ret := nil]		ifFalse: [ |temp|			temp := DictionaryPair new initialize.			temp key: (newObject key).			temp value: (self at: (newObject key)).			ret := temp].	self at: (newObject key) put: (newObject value).	^ret</body></methods><methods><class-id>NewDictionary</class-id> <category>enumerating</category><body package="CS474" selector="do:">do: aBlock	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "	^self subclassResponsibility</body></methods><methods><class-id>SortedDictionary</class-id> <category>enumerating</category><body package="CS474" selector="do:">do: aBlock	1 to: items size		do: [ :index | aBlock value: (items at: index)].	^self</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="items">items	^items</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:">at: key	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	1 to: items size		do: [ :index | 			( (items at: index) key = key)				ifTrue: [ ^(items at: index) value].			].	^nil</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: key put: value	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| pair |	1 to: items size		do: [ :index |			((items at: index) key = key)				ifTrue:[ (items at: index) value: value.					^self				]			].	pair := DictionaryPair new initialize.	pair key: key.	pair value: value.	items add: pair.	^self</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="keys">keys	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| allKeys |	allKeys := OrderedCollection new initialize.	1 to: items size		do: [ :index |			allKeys add: ((items at: index) key)].	^allKeys</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="items:">items: anObject	items := anObject.</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="values">values	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| allValues |	allValues := OrderedCollection new initialize.	1 to: items size		do: [ :index |			allValues add: ((items at: index) value)].	^allValues</body></methods><methods><class-id>SortedDictionary</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	items := SortedCollection new initialize.	items sortBlock: [ :a :b | (a key) &lt;= (b key)].	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>NewDictionaryGUI class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'CS474 Project 1: Dictionary' 			#min: #(#{Core.Point} 640 480 ) 			#max: #(#{Core.Point} 640 480 ) 			#bounds: #(#{Graphics.Rectangle} 448 172 1088 652 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 13 0 27 0 156 0 48 0 ) 					#name: #CreateTreeDictionary 					#model: #createTreeDictionary 					#label: 'Create TreeDictionary' 					#defaultable: true ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 405 0 1 0 640 0 480 0 ) 					#name: #ItemsList 					#model: #itemsList 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 285 0 28 0 400 0 49 0 ) 					#name: #AllPairs 					#model: #showAllPairs 					#label: 'All Pairs' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 285 0 62 0 400 0 83 0 ) 					#name: #AllKeys 					#model: #showAllKeys 					#label: 'Keys' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 286 0 94 0 401 0 115 0 ) 					#name: #AllValues 					#model: #showAllValues 					#label: 'Values' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 13 0 69 0 156 0 90 0 ) 					#name: #CreateSortedDictionary 					#model: #createSortedDictionary 					#label: 'Create SortedDictionary' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 24 0 171 0 124 0 190 0 ) 					#name: #KeyToAdd 					#model: #keyToAdd ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 28 0 154 0 ) 					#name: #KeyLabel 					#label: 'Key' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 150 0 171 0 250 0 190 0 ) 					#name: #ValueToAdd 					#model: #valueToAdd 					#type: #number ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 153 0 154 0 ) 					#name: #ValueLabel 					#label: 'Value' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 272 0 170 0 324 0 191 0 ) 					#name: #AddPair 					#model: #addPair 					#label: 'Add' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 26 0 243 0 126 0 262 0 ) 					#name: #KeyToGet 					#model: #keyToGet ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 28 0 225 0 ) 					#name: #KeyGetLabel 					#label: 'Get Key' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 135 0 241 0 187 0 262 0 ) 					#name: #GetKey 					#model: #getKey 					#label: 'Get' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 203 0 241 0 303 0 260 0 ) 					#name: #ValueResult 					#model: #valueResult 					#isReadOnly: true 					#type: #number ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 24 0 311 0 392 0 330 0 ) 					#name: #DoMethod 					#model: #doMethod ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 28 0 292 0 ) 					#name: #DoLabel 					#label: 'Do:' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 177 0 336 0 229 0 357 0 ) 					#name: #DoButton 					#model: #doIt 					#label: 'Do it!' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>NewDictionaryGUI</class-id> <category>actions</category><body package="CS474" selector="getKey">getKey	"This stub method was generated by UIDefiner"	| key value |	key := keyToGet value.	value := dictionary at: key.	valueResult value: value.	^self</body></methods><methods><class-id>NewDictionaryGUI</class-id> <category>actions</category><body package="CS474" selector="createSortedDictionary">createSortedDictionary	"This stub method was generated by UIDefiner"	dictionary := SortedDictionary new initialize.	^self</body></methods><methods><class-id>NewDictionaryGUI</class-id> <category>actions</category><body package="CS474" selector="addPair">addPair	"This stub method was generated by UIDefiner"	| key value |	key := keyToAdd value.	value := valueToAdd value.	dictionary at: key put: value.	^self</body></methods><methods><class-id>NewDictionaryGUI</class-id> <category>actions</category><body package="CS474" selector="createTreeDictionary">createTreeDictionary	"This stub method was generated by UIDefiner"	dictionary := TreeDictionary new initialize.	^self</body></methods><methods><class-id>NewDictionaryGUI</class-id> <category>actions</category><body package="CS474" selector="doIt">doIt	"This stub method was generated by UIDefiner"	| aBlock |	aBlock := BlockClosure readFromString: (doMethod value).	dictionary do: aBlock.	^self</body></methods><methods><class-id>NewDictionaryGUI</class-id> <category>actions</category><body package="CS474" selector="showAllPairs">showAllPairs	"This stub method was generated by UIDefiner"	| pairs |	pairs := (dictionary allPairs).	itemsList list: pairs.	^self</body></methods><methods><class-id>NewDictionaryGUI</class-id> <category>actions</category><body package="CS474" selector="showAllValues">showAllValues	"This stub method was generated by UIDefiner"	| values |	values := (dictionary values).	itemsList list: values.	^self</body></methods><methods><class-id>NewDictionaryGUI</class-id> <category>actions</category><body package="CS474" selector="showAllKeys">showAllKeys	"This stub method was generated by UIDefiner"	| keys |	keys := (dictionary keys).	itemsList list: keys.	^self</body></methods><methods><class-id>NewDictionaryGUI</class-id> <category>aspects</category><body package="CS474" selector="itemsList">itemsList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^itemsList isNil		ifTrue:			[itemsList := SelectionInList new]		ifFalse:			[itemsList]</body></methods><methods><class-id>NewDictionaryGUI</class-id> <category>aspects</category><body package="CS474" selector="keyToAdd">keyToAdd	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^keyToAdd isNil		ifTrue:			[keyToAdd := String new asValue]		ifFalse:			[keyToAdd]</body></methods><methods><class-id>NewDictionaryGUI</class-id> <category>aspects</category><body package="CS474" selector="doMethod">doMethod	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^doMethod isNil		ifTrue:			[doMethod := String new asValue]		ifFalse:			[doMethod]</body></methods><methods><class-id>NewDictionaryGUI</class-id> <category>aspects</category><body package="CS474" selector="valueResult">valueResult	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^valueResult isNil		ifTrue:			[valueResult := 0 asValue]		ifFalse:			[valueResult]</body></methods><methods><class-id>NewDictionaryGUI</class-id> <category>aspects</category><body package="CS474" selector="keyToGet">keyToGet	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^keyToGet isNil		ifTrue:			[keyToGet := String new asValue]		ifFalse:			[keyToGet]</body></methods><methods><class-id>NewDictionaryGUI</class-id> <category>aspects</category><body package="CS474" selector="valueToAdd">valueToAdd	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^valueToAdd isNil		ifTrue:			[valueToAdd := 0 asValue]		ifFalse:			[valueToAdd]</body></methods><methods><class-id>TreeDictionary</class-id> <category>enumerating</category><body package="CS474" selector="do:">do: aBlock	| allNodes |	allNodes := bst allNodes asOrderedCollection.	1 to: allNodes size		do: [ :index | aBlock value: (allNodes at: index)].	^self</body></methods><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:">at: key	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| tempNode result|	tempNode := TreeDictionaryNode new initialize.	tempNode key: key.	result := (bst get: tempNode).	(result notNil)		ifTrue: [^result value].	^nil</body></methods><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: key put: value	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| tempNode |	tempNode := TreeDictionaryNode new initialize.	tempNode key: key.	tempNode value: value.	bst insert: tempNode.	^self</body></methods><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="bst">bst	^bst</body></methods><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="keys">keys	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| allNodes allKeys|	allNodes := bst allNodes.	allKeys := allNodes collect: [:aNode | aNode key].	^allKeys asOrderedCollection.</body></methods><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="values">values	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| allNodes allValues|	allNodes := bst allNodes.	allValues := allNodes collect: [:aNode | aNode value].	^allValues asOrderedCollection.</body></methods><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="bst:">bst: anObject	bst := anObject.</body></methods><methods><class-id>TreeDictionary</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	bst := BST new initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><do-it>ALI asNameSpace organization removeCategory: #PC</do-it><do-it>ALI asNameSpace organization removeCategory: #RegA</do-it><do-it>ALI asNameSpace organization removeCategory: #RegB</do-it><shared-variable><name>Memory</name><environment>ALI</environment><private>false</private><constant>false</constant><category>New Share</category><initializer>Array new: 256</initializer><attributes><package>AssemblyInterpreter</package></attributes></shared-variable><do-it>ALI asNameSpace organization removeCategory: #Memory</do-it><do-it>ALI.Memory</do-it><do-it>ALI.Memory</do-it><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>Memory</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>Memory</staticKey> <definitionChange>added</definitionChange></component_static_change><do-it>#{ALI.Memory} removeFromSystem</do-it><do-it>ALI asNameSpace organization removeCategory: #'New Share'</do-it><shared-variable><name>Memory</name><environment>ALI</environment><private>false</private><constant>false</constant><category>New Share</category><initializer>nil</initializer><attributes><package>AssemblyInterpreter</package></attributes></shared-variable><methods><class-id>ALI class</class-id> <category>instance creation</category><body package="AssemblyInterpreter" selector="new">new	"Answer a newly created and initialized instance."	Memory := Array new: 256.	^super new initialize</body></methods><do-it>ALI.Memory</do-it><do-it>ALI.Memory</do-it><do-it>a := ALI new</do-it><do-it>a := ALI new</do-it><do-it>ALI.Memory</do-it><do-it>#{ALI.Memory} removeFromSystem</do-it><do-it>ALI asNameSpace organization removeCategory: #'New Share'</do-it><methods><class-id>ALI class</class-id> <category>instance creation</category><body package="AssemblyInterpreter" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>ALI class</class-id> <category>interface specs</category><body package="AssemblyInterpreter" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'MyCanvas' 			#bounds: #(#{Graphics.Rectangle} 908 305 1227 582 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 25 0 15 0 222 0 177 0 ) 					#name: #TextALI 					#tabRequiresControl: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 231 0 17 0 283 0 38 0 ) 					#name: #ActionNext 					#label: 'Next' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 231 0 48 0 284 0 69 0 ) 					#name: #ActionAll 					#label: 'All' 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 33 0 188 0 ) 					#name: #LblRegA 					#label: 'RegA' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 107 0 191 0 ) 					#name: #LblRegB 					#label: 'RegB' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 181 0 189 0 ) 					#name: #LblPC 					#label: 'PC' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 34 0 223 0 ) 					#name: #RegA ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 108 0 225 0 ) 					#name: #RegB ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 182 0 225 0 ) 					#name: #PC ) ) ) )</body></methods><methods><class-id>ALI class</class-id> <category>interface specs</category><body package="AssemblyInterpreter" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'MyCanvas' 			#bounds: #(#{Graphics.Rectangle} 908 305 1227 582 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 25 0 15 0 222 0 177 0 ) 					#name: #TextALI 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#tabRequiresControl: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 231 0 17 0 283 0 38 0 ) 					#name: #ActionNext 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#label: 'Next' 					#style: #default 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 231 0 48 0 284 0 69 0 ) 					#name: #ActionAll 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#label: 'All' 					#style: #default 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 33 0 188 0 ) 					#name: #LblRegA 					#label: 'RegA' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 107 0 191 0 ) 					#name: #LblRegB 					#label: 'RegB' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 181 0 189 0 ) 					#name: #LblPC 					#label: 'PC' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 34 0 223 0 ) 					#name: #RegA ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 108 0 225 0 ) 					#name: #RegB ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 182 0 225 0 ) 					#name: #PC ) ) ) )</body></methods><class><name>GUI</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AssemblyInterpreter</package></attributes></class><methods><class-id>GUI class</class-id> <category>interface specs</category><body package="AssemblyInterpreter" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'MyCanvas' 			#bounds: #(#{Graphics.Rectangle} 697 312 1016 589 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 25 0 15 0 222 0 177 0 ) 					#name: #TextALI 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#tabRequiresControl: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 231 0 17 0 283 0 38 0 ) 					#name: #ActionNext 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#label: 'Next' 					#style: #default 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 231 0 48 0 284 0 69 0 ) 					#name: #ActionAll 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#label: 'All' 					#style: #default 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 33 0 188 0 ) 					#name: #LblRegA 					#label: 'RegA' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 107 0 191 0 ) 					#name: #LblRegB 					#label: 'RegB' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 181 0 189 0 ) 					#name: #LblPC 					#label: 'PC' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 34 0 223 0 ) 					#name: #RegA ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 108 0 225 0 ) 					#name: #RegB ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 182 0 225 0 ) 					#name: #PC ) ) ) )</body></methods><remove-selector><class-id>ALI class</class-id> <selector>windowSpec</selector></remove-selector><do-it>ALI class organization removeCategory: #'interface specs'</do-it><class><name>GUI</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>TextAspect </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AssemblyInterpreter</package></attributes></class><do-it>Smalltalk defineClass: #GUI	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: ' TextAspect '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>GUI</class-id> <category>aspects</category><body package="AssemblyInterpreter" selector="TextAspect">TextAspect	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^TextAspect isNil		ifTrue:			[TextAspect := String new asValue]		ifFalse:			[TextAspect]</body></methods><class><name>GUI</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>TextAspect </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AssemblyInterpreter</package></attributes></class><do-it>Smalltalk defineClass: #GUI	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'TextAspect  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="NextAction">NextAction	"This stub method was generated by UIDefiner"	^self</body></methods><class><name>GUI</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>TextAspect </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AssemblyInterpreter</package></attributes></class><do-it>Smalltalk defineClass: #GUI	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'TextAspect  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="AllAction">AllAction	"This stub method was generated by UIDefiner"	^self</body></methods><methods><class-id>GUI class</class-id> <category>interface specs</category><body package="AssemblyInterpreter" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'MyCanvas' 			#bounds: #(#{Graphics.Rectangle} 524 226 843 503 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 25 0 15 0 222 0 177 0 ) 					#name: #TextALI 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#model: #TextAspect 					#menu: #TextMenu 					#tabRequiresControl: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 231 0 17 0 283 0 38 0 ) 					#name: #ActionNext 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#model: #NextAction 					#label: 					#(#{Kernel.UserMessage} 						#key: #NextKey 						#defaultString: 'Next' 						#catalogID: #NextCat ) 					#style: #default 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 231 0 48 0 284 0 69 0 ) 					#name: #ActionAll 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#model: #AllAction 					#label: 					#(#{Kernel.UserMessage} 						#key: #AllKey 						#defaultString: 'All' 						#catalogID: #AllCat ) 					#style: #default 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 33 0 188 0 ) 					#name: #LblRegA 					#label: 'RegA' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 107 0 191 0 ) 					#name: #LblRegB 					#label: 'RegB' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 181 0 189 0 ) 					#name: #LblPC 					#label: 'PC' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 34 0 223 0 ) 					#name: #RegA 					#label: 					#(#{Kernel.UserMessage} 						#key: #RegAKey 						#defaultString: nil 						#catalogID: #RegACat ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 108 0 225 0 ) 					#name: #RegB 					#label: 					#(#{Kernel.UserMessage} 						#key: #RegBKey 						#defaultString: nil 						#catalogID: #RegBCat ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 182 0 225 0 ) 					#name: #PC 					#label: 					#(#{Kernel.UserMessage} 						#key: #PCKey 						#defaultString: nil 						#catalogID: #PCCat ) ) ) ) )</body></methods><methods><class-id>GUI class</class-id> <category>interface specs</category><body package="AssemblyInterpreter" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'MyCanvas' 			#bounds: #(#{Graphics.Rectangle} 524 226 843 503 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 25 0 15 0 222 0 177 0 ) 					#name: #TextALI 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#model: #TextAspect 					#menu: #TextMenu 					#tabRequiresControl: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 231 0 17 0 283 0 38 0 ) 					#name: #ActionNext 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#model: #NextAction 					#label: 					#(#{Kernel.UserMessage} 						#key: #NextKey 						#defaultString: 'Next' 						#catalogID: #NextCat ) 					#style: #default 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 231 0 48 0 284 0 69 0 ) 					#name: #ActionAll 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#model: #AllAction 					#label: 					#(#{Kernel.UserMessage} 						#key: #AllKey 						#defaultString: 'All' 						#catalogID: #AllCat ) 					#style: #default 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 33 0 188 0 ) 					#name: #LblRegA 					#label: 'RegA' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 107 0 191 0 ) 					#name: #LblRegB 					#label: 'RegB' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 181 0 189 0 ) 					#name: #LblPC 					#label: 'PC' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 34 0 223 0 ) 					#name: #RegA ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 108 0 225 0 ) 					#name: #RegB ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 182 0 225 0 ) 					#name: #PC ) ) ) )</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('c:\Users\Joey\Documents\VisualWorks Projects\Project2\Project2.im' 'March 17, 2018' '1:20:38 PM')""An image file c:\Users\Joey\Documents\VisualWorks Projects\Project2\Project2.im was created at 1:20:38 PM on March 17, 2018."</do-it><class><name>GUI</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>TextAspect </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AssemblyInterpreter</package></attributes></class><do-it>Smalltalk defineClass: #GUI	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'TextAspect  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>GUI</class-id> <category>aspects</category><body package="AssemblyInterpreter" selector="TextAspect">TextAspect	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^TextAspect isNil		ifTrue:			[TextAspect := String new asValue]		ifFalse:			[TextAspect]</body></methods><methods><class-id>GUI class</class-id> <category>interface specs</category><body package="AssemblyInterpreter" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'MyCanvas' 			#bounds: #(#{Graphics.Rectangle} 524 226 843 503 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 25 0 15 0 222 0 177 0 ) 					#name: #TextALI 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#model: #TextAspect 					#tabRequiresControl: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 231 0 17 0 283 0 38 0 ) 					#name: #ActionNext 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#model: #NextAction 					#label: 					#(#{Kernel.UserMessage} 						#key: #NextKey 						#defaultString: 'Next' 						#catalogID: #NextCat ) 					#style: #default 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 231 0 48 0 284 0 69 0 ) 					#name: #ActionAll 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#model: #AllAction 					#label: 					#(#{Kernel.UserMessage} 						#key: #AllKey 						#defaultString: 'All' 						#catalogID: #AllCat ) 					#style: #default 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 33 0 188 0 ) 					#name: #LblRegA 					#label: 'RegA' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 107 0 191 0 ) 					#name: #LblRegB 					#label: 'RegB' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 181 0 189 0 ) 					#name: #LblPC 					#label: 'PC' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 34 0 223 0 ) 					#name: #RegA ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 108 0 225 0 ) 					#name: #RegB ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 182 0 225 0 ) 					#name: #PC ) ) ) )</body></methods><class><name>GUI</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>TextAspect </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AssemblyInterpreter</package></attributes></class><do-it>Smalltalk defineClass: #GUI	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'TextAspect  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>GUI</class-id> <category>aspects</category><body package="AssemblyInterpreter" selector="TextAspect">TextAspect	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^TextAspect isNil		ifTrue:			[TextAspect := String new asValue]		ifFalse:			[TextAspect]</body></methods><class><name>ALI</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>gui </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AssemblyInterpreter</package></attributes></class><methods><class-id>ALI</class-id> <category>initialize-release</category><body package="AssemblyInterpreter" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	gui := GUI new.	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><do-it>a := ALI new.</do-it><do-it>a := ALI new.</do-it><do-it>a := ALI new.</do-it><do-it>g := GUI new.</do-it><do-it>g := GUI new.</do-it><do-it>g := GUI new.</do-it><component-created><name>Ugo-2017-01-31</name> <type>package</type></component-created><class><name>QNode</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value next </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Ugo-2017-01-31</package></attributes></class><class><name>Stack</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>items </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Ugo-2017-01-31</package></attributes></class><class><name>UgosSimpleCounter</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>counter </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Ugo-2017-01-31</package></attributes></class><methods><class-id>QNode class</class-id> <category>instance creation</category><body package="Ugo-2017-01-31" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>QNode</class-id> <category>accessing</category><body package="Ugo-2017-01-31" selector="value">value	^value</body></methods><methods><class-id>QNode</class-id> <category>accessing</category><body package="Ugo-2017-01-31" selector="next">next	^next</body></methods><methods><class-id>QNode</class-id> <category>accessing</category><body package="Ugo-2017-01-31" selector="next:">next: anObject	next := anObject</body></methods><methods><class-id>QNode</class-id> <category>accessing</category><body package="Ugo-2017-01-31" selector="value:">value: anObject	value := anObject</body></methods><methods><class-id>QNode</class-id> <category>operations</category><body package="Ugo-2017-01-31" selector="insert:">insert: x	"comment stating purpose of message"	| temp |	temp := QNode new.	temp value: x.	temp next: next.	next := temp.	^self.</body></methods><methods><class-id>QNode</class-id> <category>initialize-release</category><body package="Ugo-2017-01-31" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	value := nil.	next := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>UgosSimpleCounter class</class-id> <category>interface specs</category><body package="Ugo-2017-01-31" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Ugo''s simple counter' 			#bounds: #(#{Graphics.Rectangle} 205 365 634 751 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 56 0 36 0 109 0 54 0 ) 					#name: #ActionButton1 					#model: #increment 					#label: 'UP' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 57 0 84 0 110 0 102 0 ) 					#name: #ActionButton2 					#model: #decrement 					#label: 'DOWN' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 188 0 42 0 288 0 61 0 ) 					#name: #InputField1 					#model: #counter 					#alignment: #right 					#isReadOnly: true 					#type: #number 					#formatString: '0' ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 202 0 96 0 397 0 123 0 ) 					#name: #Slider1 					#model: #counter 					#orientation: #horizontal 					#start: 0 					#stop: 100 					#step: 1 ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 194 0 89 0 ) 					#name: #Label1 					#label: '0' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 378 0 95 0 ) 					#name: #Label2 					#label: '100' ) ) ) )</body></methods><methods><class-id>UgosSimpleCounter</class-id> <category>aspects</category><body package="Ugo-2017-01-31" selector="counter">counter	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^counter isNil		ifTrue:			[counter := 0 asValue]		ifFalse:			[counter]</body></methods><methods><class-id>UgosSimpleCounter</class-id> <category>actions</category><body package="Ugo-2017-01-31" selector="decrement">decrement	"This stub method was generated by UIDefiner"	counter value: (counter value) - 1.	^self</body></methods><methods><class-id>UgosSimpleCounter</class-id> <category>actions</category><body package="Ugo-2017-01-31" selector="increment">increment	"This stub method was generated by UIDefiner"	counter value: (counter value) + 1.	^self</body></methods><methods><class-id>Stack class</class-id> <category>instance creation</category><body package="Ugo-2017-01-31" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Stack</class-id> <category>accessing</category><body package="Ugo-2017-01-31" selector="items:">items: anObject	items := anObject</body></methods><methods><class-id>Stack</class-id> <category>accessing</category><body package="Ugo-2017-01-31" selector="items">items	^items</body></methods><methods><class-id>Stack</class-id> <category>stack-operations</category><body package="Ugo-2017-01-31" selector="push:">push: x	"comment stating purpose of message"	items addFirst: x.	^self.</body></methods><methods><class-id>Stack</class-id> <category>stack-operations</category><body package="Ugo-2017-01-31" selector="contains:">contains: x	"comment stating purpose of message"	(items isEmpty) ifTrue: [^false].	items do: [:y | (y = x) ifTrue: [^true]].	^false.</body></methods><methods><class-id>Stack</class-id> <category>stack-operations</category><body package="Ugo-2017-01-31" selector="pop">pop	"comment stating purpose of message"	(items isEmpty)		ifTrue: [self error: 'Don''t pop an empty stack, please!'.]         ifFalse: [^items removeFirst.]</body></methods><methods><class-id>Stack</class-id> <category>stack-operations</category><body package="Ugo-2017-01-31" selector="top">top	"comment stating purpose of message"	(items isEmpty)		ifTrue: [self error: 'Don''t pop an empty stack, please!'.]         ifFalse: [^items first.]</body></methods><methods><class-id>Stack</class-id> <category>initialize-release</category><body package="Ugo-2017-01-31" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	items := OrderedCollection new.	^self</body></methods><do-it>u := UgosSimpleCounter new</do-it><do-it>u := UgosSimpleCounter new</do-it><do-it>u := UgosSimpleCounter new.u counter</do-it><do-it>u := UgosSimpleCounter new.u counter</do-it><do-it>u := UgosSimpleCounter new.u counter.u decrement.</do-it><do-it>u := UgosSimpleCounter new.u counter.u decrement.</do-it><do-it>u := UgosSimpleCounter new.u counter.u decrement.</do-it><methods><class-id>ALI</class-id> <category>initialize-release</category><body package="AssemblyInterpreter" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><class><name>ALI</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AssemblyInterpreter</package></attributes></class><class><name>GUI</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>TextAspect ali </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AssemblyInterpreter</package></attributes></class><class><name>GUI</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>TextAspect </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AssemblyInterpreter</package></attributes></class><class><name>ALI</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>gui </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AssemblyInterpreter</package></attributes></class><methods><class-id>ALI</class-id> <category>initialize-release</category><body package="AssemblyInterpreter" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	gui := GUI new.	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>ALI</class-id> <category>initialize-release</category><body package="AssemblyInterpreter" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	gui := GUI new.	gui open.	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><do-it>u := UgosSimpleCounter new.u open.</do-it><do-it>ALI organization addCategory: #accessing</do-it><methods><class-id>ALI</class-id> <category>accessing</category><body package="AssemblyInterpreter" selector="gui">gui	^self gui</body></methods><methods><class-id>ALI</class-id> <category>accessing</category><body package="AssemblyInterpreter" selector="gui">gui	^gui</body></methods><do-it>a := ALI new.a gui open.</do-it><do-it>a := ALI new.</do-it><do-it>u := UgosSimpleCounter new.u counter</do-it><do-it>u := UgosSimpleCounter new.u counter</do-it><do-it>u := UgosSimpleCounter new.u counter value</do-it><do-it>u := UgosSimpleCounter new.u counter value</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="NextAction">NextAction	"This stub method was generated by UIDefiner"	self TextAspect value.	^self</body></methods><methods><class-id>GUI class</class-id> <category>interface specs</category><body package="AssemblyInterpreter" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'MyCanvas' 			#bounds: #(#{Graphics.Rectangle} 1847 374 2166 651 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 25 0 15 0 222 0 177 0 ) 					#name: #TextALI 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#model: #TextAspect 					#tabRequiresControl: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 231 0 17 0 283 0 38 0 ) 					#name: #ActionNext 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#model: #NextAction 					#label: 					#(#{Kernel.UserMessage} 						#key: #NextKey 						#defaultString: 'Next' 						#catalogID: #NextCat ) 					#style: #default 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 231 0 48 0 284 0 69 0 ) 					#name: #ActionAll 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#model: #AllAction 					#label: 					#(#{Kernel.UserMessage} 						#key: #AllKey 						#defaultString: 'All' 						#catalogID: #AllCat ) 					#style: #default 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 33 0 188 0 ) 					#name: #LblRegA 					#label: 'RegA' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 34 0 213 0 ) 					#name: #LblRegB 					#label: 'RegB' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 42 0 241 0 ) 					#name: #LblPC 					#label: 'PC' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 187 0 177 0 206 0 ) 					#name: #RegA 					#model: #RegA 					#type: #string ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 78 0 213 0 178 0 232 0 ) 					#name: #RegB 					#model: #RegB ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 79 0 237 0 179 0 256 0 ) 					#name: #PC 					#model: #PC ) ) ) )</body></methods><methods><class-id>GUI class</class-id> <category>interface specs</category><body package="AssemblyInterpreter" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'MyCanvas' 			#bounds: #(#{Graphics.Rectangle} 1847 374 2166 651 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 25 0 15 0 222 0 177 0 ) 					#name: #TextALI 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#model: #TextAspect 					#tabRequiresControl: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 231 0 17 0 283 0 38 0 ) 					#name: #ActionNext 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#model: #NextAction 					#label: 					#(#{Kernel.UserMessage} 						#key: #NextKey 						#defaultString: 'Next' 						#catalogID: #NextCat ) 					#style: #default 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 231 0 48 0 284 0 69 0 ) 					#name: #ActionAll 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#model: #AllAction 					#label: 					#(#{Kernel.UserMessage} 						#key: #AllKey 						#defaultString: 'All' 						#catalogID: #AllCat ) 					#style: #default 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 33 0 188 0 ) 					#name: #LblRegA 					#label: 'RegA' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 34 0 213 0 ) 					#name: #LblRegB 					#label: 'RegB' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 42 0 241 0 ) 					#name: #LblPC 					#label: 'PC' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 187 0 177 0 206 0 ) 					#name: #RegA 					#model: #RegA 					#type: #string ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 78 0 213 0 178 0 232 0 ) 					#name: #RegB 					#model: #RegB ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 79 0 237 0 179 0 256 0 ) 					#name: #PC 					#model: #PC ) ) ) )</body></methods><class><name>GUI</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>TextAspect RegA RegB PC </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AssemblyInterpreter</package></attributes></class><do-it>Smalltalk defineClass: #GUI	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'TextAspect  RegA RegB PC '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>GUI</class-id> <category>aspects</category><body package="AssemblyInterpreter" selector="RegB">RegB	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^RegB isNil		ifTrue:			[RegB := String new asValue]		ifFalse:			[RegB]</body></methods><methods><class-id>GUI</class-id> <category>aspects</category><body package="AssemblyInterpreter" selector="TextAspect">TextAspect	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^TextAspect isNil		ifTrue:			[TextAspect := String new asValue]		ifFalse:			[TextAspect]</body></methods><methods><class-id>GUI</class-id> <category>aspects</category><body package="AssemblyInterpreter" selector="PC">PC	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^PC isNil		ifTrue:			[PC := String new asValue]		ifFalse:			[PC]</body></methods><methods><class-id>GUI</class-id> <category>aspects</category><body package="AssemblyInterpreter" selector="RegA">RegA	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^RegA isNil		ifTrue:			[RegA := String new asValue]		ifFalse:			[RegA]</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="NextAction">NextAction	| regVal |	"This stub method was generated by UIDefiner"	regVal := self TextAspect value.	self RegA value: regVal.	^self</body></methods><do-it>a := ALI new.</do-it><methods><class-id>GUI class</class-id> <category>interface specs</category><body package="AssemblyInterpreter" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'MyCanvas' 			#bounds: #(#{Graphics.Rectangle} 1847 374 2166 651 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 25 0 15 0 222 0 177 0 ) 					#name: #TextALI 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#model: #TextAspect 					#tabRequiresControl: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 231 0 17 0 283 0 38 0 ) 					#name: #ActionNext 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#model: #NextAction 					#label: 					#(#{Kernel.UserMessage} 						#key: #NextKey 						#defaultString: 'Next' 						#catalogID: #NextCat ) 					#style: #default 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 231 0 48 0 284 0 69 0 ) 					#name: #ActionAll 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#model: #AllAction 					#label: 					#(#{Kernel.UserMessage} 						#key: #AllKey 						#defaultString: 'All' 						#catalogID: #AllCat ) 					#style: #default 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 33 0 188 0 ) 					#name: #LblRegA 					#label: 'RegA' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 34 0 213 0 ) 					#name: #LblRegB 					#label: 'RegB' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 42 0 241 0 ) 					#name: #LblPC 					#label: 'PC' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 187 0 177 0 206 0 ) 					#name: #RegA 					#model: #RegA 					#isReadOnly: true 					#type: #string ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 78 0 213 0 178 0 232 0 ) 					#name: #RegB 					#model: #RegB 					#isReadOnly: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 79 0 237 0 179 0 256 0 ) 					#name: #PC 					#model: #PC 					#isReadOnly: true 					#type: #number ) ) ) )</body></methods><class><name>GUI</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>TextAspect RegA RegB PC </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AssemblyInterpreter</package></attributes></class><do-it>Smalltalk defineClass: #GUI	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'TextAspect RegA RegB PC  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>GUI</class-id> <category>aspects</category><body package="AssemblyInterpreter" selector="RegB">RegB	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^RegB isNil		ifTrue:			[RegB := String new asValue]		ifFalse:			[RegB]</body></methods><methods><class-id>GUI</class-id> <category>aspects</category><body package="AssemblyInterpreter" selector="TextAspect">TextAspect	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^TextAspect isNil		ifTrue:			[TextAspect := String new asValue]		ifFalse:			[TextAspect]</body></methods><methods><class-id>GUI</class-id> <category>aspects</category><body package="AssemblyInterpreter" selector="PC">PC	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^PC isNil		ifTrue:			[PC := 0 asValue]		ifFalse:			[PC]</body></methods><methods><class-id>GUI</class-id> <category>aspects</category><body package="AssemblyInterpreter" selector="RegA">RegA	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^RegA isNil		ifTrue:			[RegA := String new asValue]		ifFalse:			[RegA]</body></methods><do-it>aStream := 'dont you love' readStream.aStream upToAll: 'u'.</do-it><do-it>aStream := 'dont you love' readStream.aStream upToAll: ' '.</do-it><do-it>aStream := 'dont you love' readStream.aStream upToAll: ' '.aStream next.</do-it><do-it>aStream := 'dont you love' readStream.aStream upToAll: ' '.aStream next.space := aStream next.space isSeparator.</do-it><do-it>aStream := 'dont you love' readStream.aStream upToAll: ' '.aStream next.</do-it><do-it>aStream := 'dont you love' readStream.aStream upToAll: ' '.aStream next.</do-it><do-it>aStream := 'dont you love' readStream.aStream upToAll: ' '.space := aStream next.</do-it><do-it>aStream := 'dont you love' readStream.aStream upToAll: ' '.space := aStream next.space isSeparator.</do-it><do-it>aStream := 'dont you love' readStream.aStream upToAll: ' '.space := aStream next.aStream next.</do-it><do-it>aStream := 'dont you love' readStream.aStream upToAll: ' '.</do-it><do-it>aStream := 'dont you love' readStream.aStream upToAll: ' '.</do-it><do-it>aStream := 'dont you love' readStream.aStream upToAll: ' '.space := aStream next.aStream upToAll: ' '.</do-it><methods><class-id>GUI class</class-id> <category>interface specs</category><body package="AssemblyInterpreter" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'MyCanvas' 			#bounds: #(#{Graphics.Rectangle} 1979 375 2298 652 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 25 0 15 0 222 0 177 0 ) 					#name: #TextALI 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#model: #TextAspect 					#tabRequiresControl: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 231 0 17 0 283 0 38 0 ) 					#name: #ActionNext 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#model: #NextAction 					#label: 					#(#{Kernel.UserMessage} 						#key: #NextKey 						#defaultString: 'Next' 						#catalogID: #NextCat ) 					#style: #default 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 231 0 48 0 284 0 69 0 ) 					#name: #ActionAll 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#model: #AllAction 					#label: 					#(#{Kernel.UserMessage} 						#key: #AllKey 						#defaultString: 'All' 						#catalogID: #AllCat ) 					#style: #default 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 33 0 188 0 ) 					#name: #LblRegA 					#label: 'RegA' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 34 0 213 0 ) 					#name: #LblRegB 					#label: 'RegB' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 42 0 241 0 ) 					#name: #LblPC 					#label: 'PC' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 187 0 177 0 206 0 ) 					#name: #RegA 					#model: #RegA 					#isReadOnly: true 					#type: #string ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 78 0 213 0 178 0 232 0 ) 					#name: #RegB 					#model: #RegB 					#isReadOnly: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 79 0 237 0 179 0 256 0 ) 					#name: #PC 					#model: #PC 					#isReadOnly: true 					#type: #number ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 196 0 234 0 303 0 255 0 ) 					#name: #ActionButton1 					#model: #Load 					#label: 					#(#{Kernel.UserMessage} 						#key: #LoadintoMemory 						#defaultString: 'Load into Memory' ) 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 194 0 187 0 294 0 206 0 ) 					#name: #overflow 					#model: #overflow 					#type: #number ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 194 0 210 0 294 0 229 0 ) 					#name: #zero 					#model: #zero 					#type: #boolean ) ) ) )</body></methods><class><name>GUI</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>TextAspect RegA RegB PC zero </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AssemblyInterpreter</package></attributes></class><do-it>Smalltalk defineClass: #GUI	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'TextAspect RegA RegB PC  zero '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>GUI</class-id> <category>aspects</category><body package="AssemblyInterpreter" selector="zero">zero	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^zero isNil		ifTrue:			[zero := true asValue]		ifFalse:			[zero]</body></methods><class><name>GUI</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>TextAspect RegA RegB PC zero </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AssemblyInterpreter</package></attributes></class><do-it>Smalltalk defineClass: #GUI	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'TextAspect RegA RegB PC zero  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	"This stub method was generated by UIDefiner"	^self</body></methods><class><name>GUI</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>TextAspect RegA RegB PC zero overflow </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AssemblyInterpreter</package></attributes></class><do-it>Smalltalk defineClass: #GUI	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'TextAspect RegA RegB PC zero  overflow '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>GUI</class-id> <category>aspects</category><body package="AssemblyInterpreter" selector="overflow">overflow	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^overflow isNil		ifTrue:			[overflow := 0 asValue]		ifFalse:			[overflow]</body></methods><class><name>GUI</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>TextAspect RegA RegB PC zero overflow ali </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AssemblyInterpreter</package></attributes></class><class><name>ALI</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>gui galks </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AssemblyInterpreter</package></attributes></class><class><name>ALI</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>gui </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AssemblyInterpreter</package></attributes></class><do-it>GUI organization addCategory: #ali</do-it><do-it>GUI organization removeCategory: #ali</do-it><do-it>GUI organization addCategory: #accessing</do-it><methods><class-id>GUI</class-id> <category>accessing</category><body package="AssemblyInterpreter" selector="ali">ali	^ali</body></methods><remove-selector><class-id>ALI</class-id> <selector>gui</selector></remove-selector><do-it>ALI organization removeCategory: #accessing</do-it><methods><class-id>ALI</class-id> <category>initialize-release</category><body package="AssemblyInterpreter" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><class><name>ALI</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AssemblyInterpreter</package></attributes></class><class><name>ALI</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>memory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AssemblyInterpreter</package></attributes></class><class><name>ALI</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>memory symbols </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AssemblyInterpreter</package></attributes></class><do-it>ALI organization addCategory: #accessing</do-it><methods><class-id>ALI</class-id> <category>accessing</category><body package="AssemblyInterpreter" selector="memory">memory	^memory</body></methods><methods><class-id>ALI</class-id> <category>accessing</category><body package="AssemblyInterpreter" selector="symbols">symbols	^symbols</body></methods><methods><class-id>ALI</class-id> <category>initialize-release</category><body package="AssemblyInterpreter" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."		memory := Array new: 256.	symbols := Array new: 256.	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><do-it>aStream := 'dont you love' readStream.aStream upToAll: ' '.space := aStream next.aStream upToAll: ' '.aStream upToAll: ' '.</do-it><do-it>aStream := 'dont you love' readStream.word := aStream upToAll: ' '.total := 0.[word ~= ''] whileTrue: [total := total + 1. word := aStream upToAll: ' '.].</do-it><do-it>aStream := 'dont you love' readStream.word := aStream upToAll: ' '.total := 0.[word ~= ''] whileTrue: [total := total + 1. word := aStream upToAll: ' '.].total.</do-it><do-it>aStream := 'dont you love me baby' readStream.word := aStream upToAll: ' '.total := 0.[word ~= ''] whileTrue: [total := total + 1. word := aStream upToAll: ' '.].total.</do-it><do-it>aStream := 'dont you love me baby' readStream.word := aStream upToAll: ' '.</do-it><do-it>aStream := 'dont you love me baby' readStream.word := aStream upToAll: ' '.total := 0.[word ~= 'dont'] whileTrue: [total := total + 1. word := aStream upToAll: ' '.].total.</do-it><do-it>aStream := 'dont you love me baby' readStream.word := aStream upToAll: ' '.total := 0.[word ~= ''] whileTrue: [total := total + 1. word := aStream upToAll: ' '.].total.</do-it><do-it>word := aStream upToAll: ' '.</do-it><do-it>aStream := 'dont you love me baby' readStream.word := aStream upToAll: ' '.</do-it><do-it>aStream := 'dont you love me baby' readStream.word := aStream upToAll: ' '.word := aStream upToAll: ' '.</do-it><do-it>aStream := 'dont you love me baby' readStream.word := aStream upToAll: ' '.word := aStream upToAll: ' '.</do-it><do-it>aStream := 'dont you love me baby' readStream.word := aStream upToAll: ' '.space := aStream next.word := aStream upToAll: ' '.</do-it><do-it>aStream := 'dont you love me baby' readStream.word := aStream upToAll: ' '.space := ''.total := 0.[word ~= ''] whileTrue: [total := total + 1. space := aStream next. word := aStream upToAll: ' '.].total.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word newline total |	"This stub method was generated by UIDefiner"	aStream := 'hello' readStream.	word := aStream upToAll: ' '.	newline := ''.	total := 0.	[word ~= ''] whileTrue: [total := total + 1. newline := aStream next. word := aStream upToAll: ' '.].	^self</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word newline total |	"This stub method was generated by UIDefiner"	aStream := 'hello' readStream.	word := aStream upToAll: ' '.	"newline := ''."	total := 0.	[word ~= ''] whileTrue: [total := total + 1. aStream next. word := aStream upToAll: ' '.].	^self</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word total |	"This stub method was generated by UIDefiner"	aStream := 'hello' readStream.	word := aStream upToAll: ' '.	total := 0.	[word ~= ''] whileTrue: [total := total + 1. aStream next. word := aStream upToAll: ' '.].	^self</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word total |	"This stub method was generated by UIDefiner"	aStream := TextAspect vaue readStream.	word := aStream upToAll: ' '.	total := 0.	[word ~= ''] whileTrue: [total := total + 1. aStream next. word := aStream upToAll: ' '.].	^self</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word total |	"This stub method was generated by UIDefiner"	aStream := TextAspect value readStream.	word := aStream upToAll: ' '.	total := 0.	[word ~= ''] whileTrue: [total := total + 1. aStream next. word := aStream upToAll: ' '.].	^self</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word total |	"This stub method was generated by UIDefiner"	aStream := TextAspect value readStream.	word := aStream upToAll: ' '.	total := 0.	[word ~= ''] whileTrue: [RegB value: word. aStream next. word := aStream upToAll: ' '.].	^self</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word total |	"This stub method was generated by UIDefiner"	aStream := TextAspect value readStream.	word := aStream upToAll: ' '.	[word ~= ''] whileTrue: [RegB value: word. aStream next. word := aStream upToAll: ' '.].	^self</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word |	"This stub method was generated by UIDefiner"	aStream := TextAspect value readStream.	word := aStream upToAll: ' '.	[word ~= ''] whileTrue: [RegB value: word. aStream next. word := aStream upToAll: ' '.].	^self</body></methods><do-it>GUI open.</do-it><do-it>aStream := 'dont you love me baby' readStream.word := aStream upToAll: ' '.total := 0.[word ~= ''] whileTrue: [total := total + 1. aStream next. word := aStream upToAll: ' '.].total.</do-it><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word total|	"This stub method was generated by UIDefiner"	"aStream := TextAspect value readStream.	word := aStream upToAll: ' '.	[word ~= ''] whileTrue: [RegB value: word. aStream next. word := aStream upToAll: ' '.]."		aStream := 'dont you love me baby' readStream.	word := aStream upToAll: ' '.	total := 0.	[word ~= ''] whileTrue: [total := total + 1. aStream next. word := aStream upToAll: ' '.].	RegB := total asString.	^self</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word total|	"This stub method was generated by UIDefiner"	"aStream := TextAspect value readStream.	word := aStream upToAll: ' '.	[word ~= ''] whileTrue: [RegB value: word. aStream next. word := aStream upToAll: ' '.]."		aStream := 'dont you love me baby' readStream.	word := aStream upToAll: ' '.	total := 0.	[word ~= ''] whileTrue: [total := total + 1. aStream next. word := aStream upToAll: ' '.].	RegB := total printString.	^self</body></methods><do-it>GUI open.</do-it><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word total|	"This stub method was generated by UIDefiner"	"aStream := TextAspect value readStream.	word := aStream upToAll: ' '.	[word ~= ''] whileTrue: [RegB value: word. aStream next. word := aStream upToAll: ' '.]."		aStream := 'dont you love me baby' readStream.	word := aStream upToAll: ' '.	total := 0.	[word ~= ''] whileTrue: [total := total + 1. aStream next. word := aStream upToAll: ' '.].	RegB value: total printString.	^self</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word total|	"This stub method was generated by UIDefiner"	"aStream := TextAspect value readStream.	word := aStream upToAll: ' '.	[word ~= ''] whileTrue: [RegB value: word. aStream next. word := aStream upToAll: ' '.]."		aStream := TextAspect value readStream.	word := aStream upToAll: ' '.	total := 0.	[word ~= ''] whileTrue: [total := total + 1. aStream next. word := aStream upToAll: ' '.].	RegB value: total printString.	^self</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word total|	"This stub method was generated by UIDefiner"	"aStream := TextAspect value readStream.	word := aStream upToAll: ' '.	[word ~= ''] whileTrue: [RegB value: word. aStream next. word := aStream upToAll: ' '.]."		aStream := TextAspect value readStream.	RegB value: aStream.	"word := aStream upToAll: ' '.	total := 0."	"[word ~= ''] whileTrue: [total := total + 1. aStream next. word := aStream upToAll: ' '.].	RegB value: total printString."	^self</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream |	"This stub method was generated by UIDefiner"	"aStream := TextAspect value readStream.	word := aStream upToAll: ' '.	[word ~= ''] whileTrue: [RegB value: word. aStream next. word := aStream upToAll: ' '.]."		aStream := TextAspect value readStream.	RegB value: aStream.	"word := aStream upToAll: ' '.	total := 0."	"[word ~= ''] whileTrue: [total := total + 1. aStream next. word := aStream upToAll: ' '.].	RegB value: total printString."	^self</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream |	"This stub method was generated by UIDefiner"	"aStream := TextAspect value readStream.	word := aStream upToAll: ' '.	[word ~= ''] whileTrue: [RegB value: word. aStream next. word := aStream upToAll: ' '.]."		aStream := TextAspect value.	RegB value: aStream.	"word := aStream upToAll: ' '.	total := 0."	"[word ~= ''] whileTrue: [total := total + 1. aStream next. word := aStream upToAll: ' '.].	RegB value: total printString."	^self</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream |	"This stub method was generated by UIDefiner"	"aStream := TextAspect value readStream.	word := aStream upToAll: ' '.	[word ~= ''] whileTrue: [RegB value: word. aStream next. word := aStream upToAll: ' '.]."		aStream := TextAspect value readStream.	RegB value: aStream upToAll: ' '.	"word := aStream upToAll: ' '.	total := 0."	"[word ~= ''] whileTrue: [total := total + 1. aStream next. word := aStream upToAll: ' '.].	RegB value: total printString."	^self</body></methods><do-it>GUI open.</do-it><do-it>aStream := 'dont you love me baby' readStream.word := aStream upToAll: ' '.total := 0.[word ~= ''] whileTrue: [total := total + 1. aStream next. word := aStream upToAll: ' '.].total.</do-it><do-it>aStream := 'dont you love me baby' readStream.word := aStream upToAll: ' '.total := 0.[word ~= ''] whileTrue: [total := total + 1. aStream next. word := aStream upToAll: ' '.].total.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream |	"This stub method was generated by UIDefiner"	"aStream := TextAspect value readStream.	word := aStream upToAll: ' '.	[word ~= ''] whileTrue: [RegB value: word. aStream next. word := aStream upToAll: ' '.]."		aStream := TextAspect value readStream.	RegB value: (aStream upToAll: ' ').	"word := aStream upToAll: ' '.	total := 0."	"[word ~= ''] whileTrue: [total := total + 1. aStream next. word := aStream upToAll: ' '.].	RegB value: total printString."	^self</body></methods><do-it>GUI open.</do-it><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream |	"This stub method was generated by UIDefiner"	"aStream := TextAspect value readStream.	word := (aStream upToAll: ' ').	[word ~= ''] whileTrue: [RegB value: word. aStream next. word := aStream upToAll: ' '.]."		aStream := TextAspect value readStream.	aStream next.	RegB value: (aStream upToAll: ' ').	"word := aStream upToAll: ' '.	total := 0."	"[word ~= ''] whileTrue: [total := total + 1. aStream next. word := aStream upToAll: ' '.].	RegB value: total printString."	^self</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word total|	"This stub method was generated by UIDefiner"	aStream := TextAspect value readStream.	word := (aStream upToAll: ' ').	[word ~= nil | word ~= ''] whileTrue: [RegB value: word. aStream next. word := aStream upToAll: ' '.].		"aStream := TextAspect value readStream.	aStream next.	RegB value: (aStream upToAll: ' ')."	"word := aStream upToAll: ' '.	total := 0.	[word ~= ''] whileTrue: [total := total + 1. aStream next. word := aStream upToAll: ' '.].	RegB value: total printString."	^self</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word |	"This stub method was generated by UIDefiner"	aStream := TextAspect value readStream.	word := (aStream upToAll: ' ').	[word ~= nil | word ~= ''] whileTrue: [RegB value: word. aStream next. word := aStream upToAll: ' '.].		"aStream := TextAspect value readStream.	aStream next.	RegB value: (aStream upToAll: ' ')."	"word := aStream upToAll: ' '.	total := 0.	[word ~= ''] whileTrue: [total := total + 1. aStream next. word := aStream upToAll: ' '.].	RegB value: total printString."	^self</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word |	"This stub method was generated by UIDefiner"	aStream := TextAspect value readStream.	word := (aStream upToAll: ' ').	[(word ~= nil) | (word ~= '')] whileTrue: [RegB value: word. aStream next. word := aStream upToAll: ' '.].		"aStream := TextAspect value readStream.	aStream next.	RegB value: (aStream upToAll: ' ')."	"word := aStream upToAll: ' '.	total := 0.	[word ~= ''] whileTrue: [total := total + 1. aStream next. word := aStream upToAll: ' '.].	RegB value: total printString."	^self</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word |	"This stub method was generated by UIDefiner"	aStream := TextAspect value readStream.	word := (aStream upToAll: ' ').	[word ~= ''] whileTrue: [RegB value: word. 		aStream next. 		word := aStream upToAll: ' '. 		[word = nil] ifTrue: (word := '')].		"aStream := TextAspect value readStream.	aStream next.	RegB value: (aStream upToAll: ' ')."	"word := aStream upToAll: ' '.	total := 0.	[word ~= ''] whileTrue: [total := total + 1. aStream next. word := aStream upToAll: ' '.].	RegB value: total printString."	^self</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word |	"This stub method was generated by UIDefiner"	aStream := TextAspect value readStream.	word := (aStream upToAll: ' ').	[word ~= ''] whileTrue: [RegB value: word. 		aStream next. 		word := aStream upToAll: ' '. 		[word = nil] ifTrue: [word := '']].		"aStream := TextAspect value readStream.	aStream next.	RegB value: (aStream upToAll: ' ')."	"word := aStream upToAll: ' '.	total := 0.	[word ~= ''] whileTrue: [total := total + 1. aStream next. word := aStream upToAll: ' '.].	RegB value: total printString."	^self</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word |	"This stub method was generated by UIDefiner"	aStream := TextAspect value readStream.	word := (aStream upToAll: ' ').	[word ~= nil] whileTrue: [RegB value: word. 		aStream next. 		word := aStream upToAll: ' '.].		"aStream := TextAspect value readStream.	aStream next.	RegB value: (aStream upToAll: ' ')."	"word := aStream upToAll: ' '.	total := 0.	[word ~= ''] whileTrue: [total := total + 1. aStream next. word := aStream upToAll: ' '.].	RegB value: total printString."	^self</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word |	"This stub method was generated by UIDefiner"	aStream := TextAspect value readStream.	word := (aStream upToAll: ' ').	[word ~= nil] whileTrue: [RegB value: word. 		aStream next. 		word := aStream upToAll: ' '.		[word = nil] ifTrue: [word := '']].		"aStream := TextAspect value readStream.	aStream next.	RegB value: (aStream upToAll: ' ')."	"word := aStream upToAll: ' '.	total := 0.	[word ~= ''] whileTrue: [total := total + 1. aStream next. word := aStream upToAll: ' '.].	RegB value: total printString."	^self</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word |	"This stub method was generated by UIDefiner"	aStream := TextAspect value readStream.	word := (aStream upToAll: ' ').	[word ~= ''] whileTrue: [RegB value: word. 		aStream next. 		word := aStream upToAll: ' '.		[word = nil] ifTrue: [word := '']].		"aStream := TextAspect value readStream.	aStream next.	RegB value: (aStream upToAll: ' ')."	"word := aStream upToAll: ' '.	total := 0.	[word ~= ''] whileTrue: [total := total + 1. aStream next. word := aStream upToAll: ' '.].	RegB value: total printString."	^self</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word |	"This stub method was generated by UIDefiner"	aStream := TextAspect value readStream.	word := (aStream upToAll: ' ').	[aStream atEnd] whileTrue: [RegB value: word. 		aStream next. 		word := aStream upToAll: ' '.].		"aStream := TextAspect value readStream.	aStream next.	RegB value: (aStream upToAll: ' ')."	"word := aStream upToAll: ' '.	total := 0.	[word ~= ''] whileTrue: [total := total + 1. aStream next. word := aStream upToAll: ' '.].	RegB value: total printString."	^self</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word |	"This stub method was generated by UIDefiner"	aStream := TextAspect value readStream.	word := (aStream upToAll: ' ').	[aStream atEnd] whileFalse: [RegB value: word. 		aStream next. 		word := aStream upToAll: ' '.].		"aStream := TextAspect value readStream.	aStream next.	RegB value: (aStream upToAll: ' ')."	"word := aStream upToAll: ' '.	total := 0.	[word ~= ''] whileTrue: [total := total + 1. aStream next. word := aStream upToAll: ' '.].	RegB value: total printString."	^self</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word |	"This stub method was generated by UIDefiner"	aStream := TextAspect value readStream.	word := (aStream upToAll: ' ').	[aStream atEnd] whileFalse: [RegB value: word. 		aStream next. 		word := aStream upToAll: ' '.		RegB value: word. ].		"aStream := TextAspect value readStream.	aStream next.	RegB value: (aStream upToAll: ' ')."	"word := aStream upToAll: ' '.	total := 0.	[word ~= ''] whileTrue: [total := total + 1. aStream next. word := aStream upToAll: ' '.].	RegB value: total printString."	^self</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word |	"This stub method was generated by UIDefiner"	aStream := TextAspect value readStream.	word := (aStream upToAll: ' ').	[aStream atEnd] whileFalse: [RegB value: word. 		aStream next. 		word := aStream upToAll: ' '.].	RegB value: word.		"aStream := TextAspect value readStream.	aStream next.	RegB value: (aStream upToAll: ' ')."	"word := aStream upToAll: ' '.	total := 0.	[word ~= ''] whileTrue: [total := total + 1. aStream next. word := aStream upToAll: ' '.].	RegB value: total printString."	^self</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word index|	"This stub method was generated by UIDefiner"	ali := ALI new.	index := 1.	aStream := TextAspect value readStream.	word := (aStream upToAll: ' ').	[aStream atEnd] whileFalse: [RegB value: word. 		aStream next. 		word := aStream upToAll: ' '.].	RegB value: word.		"aStream := TextAspect value readStream.	aStream next.	RegB value: (aStream upToAll: ' ')."	"word := aStream upToAll: ' '.	total := 0.	[word ~= ''] whileTrue: [total := total + 1. aStream next. word := aStream upToAll: ' '.].	RegB value: total printString."	^self</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word index|	"This stub method was generated by UIDefiner"	ali := ALI new.	index := 1.	aStream := TextAspect value readStream.	word := (aStream upToAll: ' ').	[aStream atEnd] whileFalse: [		ali memory at: index put: word. 		aStream next. 		word := aStream upToAll: ' '.		index := index + 1.		].	ali memory at: index put: word.		"aStream := TextAspect value readStream.	aStream next.	RegB value: (aStream upToAll: ' ')."	"word := aStream upToAll: ' '.	total := 0.	[word ~= ''] whileTrue: [total := total + 1. aStream next. word := aStream upToAll: ' '.].	RegB value: total printString."	^self</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word index|	"This stub method was generated by UIDefiner"	ali := ALI new.	index := 1.	aStream := TextAspect value readStream.	word := (aStream upToAll: ' ').	[aStream atEnd] whileFalse: [		ali memory at: index put: word. 		aStream next. 		word := aStream upToAll: ' '.		index := index + 1.		].	ali memory at: index put: word.		^self</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word index|	"This stub method was generated by UIDefiner"	ali := ALI new.	index := 1.	aStream := TextAspect value readStream.	word := (aStream upToAll: ' ').	[aStream atEnd] whileFalse: [		ali memory at: index put: word. 		aStream next. 		word := aStream upToAll: ' '.		index := index + 1.		].	ali memory at: index put: word.		RegB value: (ali memory at: 2).		^self</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word index|	"This stub method was generated by UIDefiner"	ali := ALI new.	index := 1.	aStream := TextAspect value readStream.	word := (aStream upToAll: ' ').	[aStream atEnd] whileFalse: [		ali memory at: index put: word. 		aStream next. 		word := aStream upToAll: ' '.		index := index + 1.		].	ali memory at: index put: word.		^self</body></methods><methods><class-id>GUI</class-id> <category>aspects</category><body package="AssemblyInterpreter" selector="PC">PC	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^PC isNil		ifTrue:			[PC := 1 asValue]		ifFalse:			[PC]</body></methods><class><name>SAL</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AssemblyInterpreter</package></attributes></class><methods><class-id>SAL</class-id> <category>initialize-release</category><body package="AssemblyInterpreter" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>SAL class</class-id> <category>instance creation</category><body package="AssemblyInterpreter" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><do-it>SAL organization addCategory: #command</do-it><methods><class-id>SAL</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command">command	^self subclassResponsibility</body></methods><class><name>DEC</name><environment>Smalltalk</environment><super>SAL</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AssemblyInterpreter</package></attributes></class><methods><class-id>DEC</class-id> <category>initialize-release</category><body package="AssemblyInterpreter" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>DEC</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command">command	" *** This method was defined by SAL as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><class><name>DEC</name><environment>Smalltalk</environment><super>SAL</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AssemblyInterpreter</package></attributes></class><class><name>LDI</name><environment>Smalltalk</environment><super>SAL</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AssemblyInterpreter</package></attributes></class><methods><class-id>LDI</class-id> <category>initialize-release</category><body package="AssemblyInterpreter" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>LDI</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command">command	" *** This method was defined by SAL as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><class><name>LDI</name><environment>Smalltalk</environment><super>SAL</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AssemblyInterpreter</package></attributes></class><do-it>LDI organization addCategory: #accessing</do-it><methods><class-id>LDI</class-id> <category>accessing</category><body package="AssemblyInterpreter" selector="value">value	^value</body></methods><methods><class-id>LDI</class-id> <category>accessing</category><body package="AssemblyInterpreter" selector="value:">value: aNumber	value := aNumber.	^value</body></methods><methods><class-id>SAL</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGUI	^self subclassResponsibility</body></methods><methods><class-id>LDI</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGui	aGui RegA value: value.	^self</body></methods><methods><class-id>LDI</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGui	aGui RegA value: (value printString).	^self</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="NextAction">NextAction	| inst val index ldi|	index := 1.	inst := ali memory at: index.	index := index + 1.	val := ali memory at: index.		[inst = 'LDI']	ifTrue:[	ldi := LDI new.	ldi value: val.	].		^self</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="NextAction">NextAction	| inst val index ldi|	index := 1.	inst := ali memory at: index.	index := index + 1.	val := ali memory at: index.		[inst = 'LDI'] ifTrue:[	ldi := LDI new.	ldi value: val.	].		^self</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="NextAction">NextAction	| inst val index ldi|	index := 1.	inst := ali memory at: index.	index := index + 1.	val := ali memory at: index.		[inst = 'LDI'] 	ifTrue:[	ldi := LDI new.	ldi value: val.	].		^self</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="NextAction">NextAction	| inst val index ldi|	index := 1.	inst := ali memory at: index.	index := index + 1.	val := ali memory at: index.		[inst = 'LDI'] 	ifTrue:[	ldi := LDI new.	ldi value: val.	ldi command: self.	].		^self</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="NextAction">NextAction	| inst val index ldi|	index := 1.	inst := ali memory at: index.	index := index + 1.	val := ali memory at: index.		(inst = 'LDI') 	ifTrue:[	ldi := LDI new.	ldi value: val.	ldi command: self.	]	ifFalse: [^self.].		^self</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="NextAction">NextAction	| inst val index ldi|	index := 1.	inst := ali memory at: index.	index := index + 1.	val := ali memory at: index.		"(inst = 'LDI') 	ifTrue:[	ldi := LDI new.	ldi value: val.	ldi command: self.	]	ifFalse: [^self.]."		^self</body></methods><do-it>GUI open.</do-it><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="NextAction">NextAction	| inst val index ldi|	index := 1.	inst := ali memory at: index.	index := index + 1.	val := ali memory at: index.		(inst = 'LDI') 	ifTrue:[	ldi := LDI new.	ldi value: val.	ldi command: self.	]	ifFalse: [^self.].		^self</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="NextAction">NextAction	| inst val index ldi|	index := 1.	inst := ali memory at: index.	index := index + 1.	val := ali memory at: index.		((inst asString) = 'LDI') 	ifTrue:[	ldi := LDI new.	ldi value: val.	ldi command: self.	]	ifFalse: [^self.].		^self</body></methods><do-it>GUI open.</do-it><methods><class-id>LDI</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGui	aGui RegA value: value.	^self</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="NextAction">NextAction	| inst val index ldi|	index := 1.	inst := ali memory at: index.	index := index + 1.	val := ali memory at: index.		((inst asString) = 'LDI') 	ifTrue:[	ldi := LDI new.	ldi value: (val asNumber).	ldi command: self.	]	ifFalse: [^self.].		^self</body></methods><do-it>GUI open.</do-it><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="NextAction">NextAction	| inst val index ldi|	index := 1.	inst := ali memory at: index.	index := index + 1.	val := ali memory at: index.		((inst asString) = 'LDI') 	ifTrue:[	ldi := LDI new.	ldi value: val.	ldi command: self.	]	ifFalse: [^self.].		^self</body></methods><do-it>GUI open.</do-it><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word index|	"This stub method was generated by UIDefiner"	ali := ALI new.	index := 1.	aStream := TextAspect value readStream.	word := (aStream upToAll: Character cr).	[aStream atEnd] whileFalse: [		ali memory at: index put: word. 		aStream next. 		word := aStream upToAll: ' '.		index := index + 1.		].	ali memory at: index put: word.		^self</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word index|	"This stub method was generated by UIDefiner"	ali := ALI new.	index := 1.	aStream := TextAspect value readStream.	word := (aStream upToAll: (Character cr)).	[aStream atEnd] whileFalse: [		ali memory at: index put: word. 		aStream next. 		word := aStream upToAll: ' '.		index := index + 1.		].	ali memory at: index put: word.		^self</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word index|	"This stub method was generated by UIDefiner"	ali := ALI new.	index := 1.	aStream := TextAspect value readStream.	word := (aStream upToAll: Character cr).	[aStream atEnd] whileFalse: [		ali memory at: index put: word. 		aStream next. 		word := aStream upToAll: Character cr.		index := index + 1.		].	ali memory at: index put: word.		^self</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word index|	"This stub method was generated by UIDefiner"	ali := ALI new.	index := 1.	aStream := TextAspect value readStream.	word := (aStream upToAll: (Character cr)).	[aStream atEnd] whileFalse: [		ali memory at: index put: word. 		aStream next. 		word := aStream upToAll: (Character cr).		index := index + 1.		].	ali memory at: index put: word.		^self</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word index|	"This stub method was generated by UIDefiner"	ali := ALI new.	index := 1.	aStream := TextAspect value readStream.	word := (aStream upToAll: (Character cr)).	RegB value: word.	[aStream atEnd] whileFalse: [		ali memory at: index put: word. 		aStream next. 		word := aStream upToAll: (Character cr).		index := index + 1.		].	ali memory at: index put: word.		^self</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word index|	"This stub method was generated by UIDefiner"	ali := ALI new.	index := 1.	aStream := TextAspect value readStream.	word := (aStream upToAll: Character cr).	RegB value: word.	[aStream atEnd] whileFalse: [		ali memory at: index put: word. 		aStream next. 		word := aStream upToAll: Character cr.		index := index + 1.		].	ali memory at: index put: word.		^self</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word index|	"This stub method was generated by UIDefiner"	ali := ALI new.	index := 1.	aStream := TextAspect value readStream.	word := (aStream upToAll: Character cr).	RegA value: word.	[aStream atEnd] whileFalse: [		ali memory at: index put: word. 		aStream next. 		word := aStream upToAll: Character cr.		index := index + 1.		].	ali memory at: index put: word.		^self</body></methods><do-it>GUI open.</do-it><do-it>aStream := 'dont you love me baby' readStream.word := aStream upToAll: ' '.total := 0.[word ~= ''] whileTrue: [total := total + 1. aStream next. word := aStream upToAll: ' '.].total.</do-it><do-it>aStream := ('dont', ' you love me baby') readStream.word := aStream upToAll: ' '.total := 0.[word ~= ''] whileTrue: [total := total + 1. aStream next. word := aStream upToAll: ' '.].total.</do-it><do-it>hi := ('hi', 'hii')</do-it><do-it>hi := ('hi', 'hii').Transcript cr; show: hi.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word index|	"This stub method was generated by UIDefiner"	ali := ALI new.	index := 1.	aStream := TextAspect value readStream.	word := (aStream upToAll: Transcript cr).	RegA value: word.	[aStream atEnd] whileFalse: [		ali memory at: index put: word. 		aStream next. 		word := aStream upToAll: Transcript cr.		index := index + 1.		].	ali memory at: index put: word.		^self</body></methods><do-it>GUI open.</do-it><do-it>aStream := ('dont', ' you love me baby') readStream.word := aStream upToAll: Character cr.total := 0.[word ~= ''] whileTrue: [total := total + 1. aStream next. word := aStream upToAll: Character cr.].total.</do-it><do-it>aStream := ('dont', ' you love me baby') readStream.word := aStream upToAll: Character cr.total := 0.[word ~= ''] whileTrue: [total := total + 1. aStream next. word := aStream upToAll: Character cr.].total.</do-it><do-it>aStream := ('dont', ' you love me baby') readStream.word := aStream upTo: ''.total := 0.[word ~= ''] whileTrue: [total := total + 1. aStream next. word := aStream upTo: ''.].total.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word index|	"This stub method was generated by UIDefiner"	ali := ALI new.	index := 1.	aStream := TextAspect value readStream.	word := (aStream upTo: Character cr).	RegA value: word.	[aStream atEnd] whileFalse: [		ali memory at: index put: word. 		aStream next. 		word := aStream upTo: Character cr.		index := index + 1.		].	ali memory at: index put: word.		^self</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word index|	"This stub method was generated by UIDefiner"	ali := ALI new.	index := 1.	aStream := TextAspect value readStream.	word := (aStream upTo: Character cr).	RegA value: word.	[aStream atEnd] whileFalse: [		ali memory at: index put: word. 		aStream next. 		word := aStream upTo: (Character cr).		index := index + 1.		].	ali memory at: index put: word.		^self</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word index|	"This stub method was generated by UIDefiner"	ali := ALI new.	index := 1.	aStream := TextAspect value readStream.	word := (aStream upTo: (Character cr)).	RegA value: word.	[aStream atEnd] whileFalse: [		ali memory at: index put: word. 		aStream next. 		word := aStream upTo: (Character cr).		index := index + 1.		].	ali memory at: index put: word.		^self</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word index|	"This stub method was generated by UIDefiner"	ali := ALI new.	index := 1.	aStream := TextAspect value readStream.	word := (aStream upTo: (Character cr)).	RegA value: word.	[aStream atEnd] whileFalse: [		ali memory at: index put: word. 		aStream next. 		word := (aStream upTo: (Character cr)).		index := index + 1.		].	ali memory at: index put: word.		^self</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word index|	"This stub method was generated by UIDefiner"	ali := ALI new.	index := 1.	aStream := TextAspect value readStream.	word := (aStream upTo: (Character cr)).	RegA value: word.	[aStream atEnd] whileFalse: [		ali memory at: index put: word. 		aStream next. 		word := (aStream upTo: (Character cr)).		RegB value: word.		index := index + 1.		].	ali memory at: index put: word.		^self</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word index|	"This stub method was generated by UIDefiner"	ali := ALI new.	index := 1.	aStream := TextAspect value readStream.	word := (aStream upTo: (Character cr)).	RegA value: word.	[aStream atEnd] whileFalse: [		ali memory at: index put: word. 		"aStream next. "		word := (aStream upTo: (Character cr)).		RegB value: word.		index := index + 1.		].	ali memory at: index put: word.		^self</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word index|	"This stub method was generated by UIDefiner"	ali := ALI new.	index := 1.	aStream := TextAspect value readStream.	word := (aStream upTo: (Character cr)).	[aStream atEnd] whileFalse: [		ali memory at: index put: word. 		word := (aStream upTo: (Character cr)).		index := index + 1.		].	ali memory at: index put: word.		^self</body></methods><remove-selector><class-id>SAL</class-id> <selector>command</selector></remove-selector><methods><class-id>DEC</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGui		^self</body></methods><remove-selector><class-id>DEC</class-id> <selector>command</selector></remove-selector><remove-selector><class-id>LDI</class-id> <selector>command</selector></remove-selector><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="NextAction">NextAction	| inst val index ldi|	PC := 1.	inst := ali memory at: index.	index := index + 1.	val := ali memory at: index.		((inst asString) = 'LDI') 	ifTrue:[	ldi := LDI new.	ldi value: val.	ldi command: self.	]	ifFalse: [^self.].		^self</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="NextAction">NextAction	| inst val ldi|	PC := 1.	inst := ali memory at: PC.	PC := PC + 1.	val := ali memory at: PC.		((inst asString) = 'LDI') 	ifTrue:[	ldi := LDI new.	ldi value: val.	ldi command: self.	]	ifFalse: [^self.].		^self</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="NextAction">NextAction	| inst val ldi|	inst := ali memory at: PC.	PC := PC + 1.	val := ali memory at: PC.		((inst asString) = 'LDI') 	ifTrue:[	ldi := LDI new.	ldi value: val.	ldi command: self.	]	ifFalse: [^self.].		^self</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="NextAction">NextAction	| inst val ldi pc|	pc := PC asNumber.	inst := ali memory at: pc.	pc := pc + 1.	val := ali memory at: pc.		((inst asString) = 'LDI') 	ifTrue:[	ldi := LDI new.	ldi value: val.	ldi command: self.	]	ifFalse: [^self.].		^self</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="NextAction">NextAction	| inst val ldi|	inst := ali memory at: PC.	PC := PC + 1.	val := ali memory at: PC.		((inst asString) = 'LDI') 	ifTrue:[	ldi := LDI new.	ldi value: val.	ldi command: self.	]	ifFalse: [^self.].		^self</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="NextAction">NextAction	| inst val ldi|	PC := 1.	inst := ali memory at: PC.	PC := PC + 1.	val := ali memory at: PC.		((inst asString) = 'LDI') 	ifTrue:[	ldi := LDI new.	ldi value: val.	ldi command: self.	]	ifFalse: [^self.].		^self</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word index|	"This stub method was generated by UIDefiner"	ali := ALI new.	index := 1.	aStream := TextAspect value readStream.	word := (aStream upTo: (Character cr)).	[aStream atEnd] whileFalse: [		ali memory at: index put: word. 		word := (aStream upTo: (Character cr)).		index := index + 1.		].	ali memory at: index put: word.		PC := 1.		^self</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="NextAction">NextAction	| inst val ldi|	inst := ali memory at: PC.	PC := PC + 1.	val := ali memory at: PC.		((inst asString) = 'LDI') 	ifTrue:[	ldi := LDI new.	ldi value: val.	ldi command: self.	]	ifFalse: [^self.].		^self</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="NextAction">NextAction	| inst val dec lda ldb ldi st xch jmp jzs jvs add hlt|	inst := ali memory at: PC.	PC := PC + 1.	val := ali memory at: PC.		((inst asString) = 'LDI') 	ifTrue:[	ldi := LDI new.	ldi value: val.	ldi command: self.	].		^self</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="NextAction">NextAction	| inst val dec lda ldb ldi st xch jmp jzs jvs add hlt|	inst := ali memory at: PC.		((inst asString) = 'LDI') 	ifTrue:[	PC := PC + 1.	val := ali memory at: PC.	ldi := LDI new.	ldi value: val.	ldi command: self.	].		^self</body></methods><do-it>GUI open.</do-it><do-it>DEC organization addCategory: #accessing</do-it><methods><class-id>DEC</class-id> <category>accessing</category><body package="AssemblyInterpreter" selector="value">value	^value</body></methods><methods><class-id>DEC</class-id> <category>accessing</category><body package="AssemblyInterpreter" selector="value:">value: aSymbol	value := aSymbol.	^value</body></methods><class><name>GUI</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>TextAspect RegA RegB PC zero overflow ali sindex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AssemblyInterpreter</package></attributes></class><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word index|	"This stub method was generated by UIDefiner"	ali := ALI new.	index := 1.	aStream := TextAspect value readStream.	word := (aStream upTo: (Character cr)).	[aStream atEnd] whileFalse: [		ali memory at: index put: word. 		word := (aStream upTo: (Character cr)).		index := index + 1.		].	ali memory at: index put: word.		PC := 1.	sindex := 1.		^self</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="NextAction">NextAction	| inst val dec lda ldb ldi st xch jmp jzs jvs add hlt|	PC := PC + 1.	sindex := sindex + 1.	inst := ali memory at: PC.		((inst asString) = 'LDI') 	ifTrue:[	PC := PC + 1.	sindex := sindex + 1.	val := ali memory at: PC.	ldi := LDI new.	ldi value: val.	ldi command: self.	].		^self</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word index|	"This stub method was generated by UIDefiner"	ali := ALI new.	index := 1.	aStream := TextAspect value readStream.	word := (aStream upTo: (Character cr)).	[aStream atEnd] whileFalse: [		ali memory at: index put: word. 		word := (aStream upTo: (Character cr)).		index := index + 1.		].	ali memory at: index put: word.		PC := 0.	sindex := 0.		^self</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="NextAction">NextAction	| inst val dec lda ldb ldi st xch jmp jzs jvs add hlt|	PC := PC + 1.	inst := ali memory at: PC.		((inst asString) = 'DEC') 	ifTrue:[	PC := PC + 1.	val := ali memory at: PC.	ali symbols at: PC put: val.	ldi := LDI new.	ldi value: val.	ldi command: self.	].		((inst asString) = 'LDI') 	ifTrue:[	PC := PC + 1.	val := ali memory at: PC.	ldi := LDI new.	ldi value: val.	ldi command: self.	].		^self</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word index|	"This stub method was generated by UIDefiner"	ali := ALI new.	index := 1.	aStream := TextAspect value readStream.	word := (aStream upTo: (Character cr)).	[aStream atEnd] whileFalse: [		ali memory at: index put: word. 		word := (aStream upTo: (Character cr)).		index := index + 1.		].	ali memory at: index put: word.		PC := 0.		^self</body></methods><class><name>GUI</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>TextAspect RegA RegB PC zero overflow ali </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AssemblyInterpreter</package></attributes></class><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="NextAction">NextAction	| inst val dec lda ldb ldi st xch jmp jzs jvs add hlt|	PC := PC + 1.	inst := ali memory at: PC.		((inst asString) = 'DEC') 	ifTrue:[	PC := PC + 1.	val := ali memory at: PC.	dec := DEC new.	dec value: val.	dec command: self.	].		((inst asString) = 'LDI') 	ifTrue:[	PC := PC + 1.	val := ali memory at: PC.	ldi := LDI new.	ldi value: val.	ldi command: self.	].		^self</body></methods><methods><class-id>DEC</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGui	aGui ali symbols at: (aGui PC) put: value.		^self</body></methods><class><name>LDA</name><environment>Smalltalk</environment><super>SAL</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AssemblyInterpreter</package></attributes></class><methods><class-id>LDA</class-id> <category>initialize-release</category><body package="AssemblyInterpreter" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>LDA</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGUI	" *** This method was defined by SAL as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><class><name>LDA</name><environment>Smalltalk</environment><super>SAL</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AssemblyInterpreter</package></attributes></class><do-it>LDA organization addCategory: #accessing</do-it><methods><class-id>LDA</class-id> <category>accessing</category><body package="AssemblyInterpreter" selector="value">value	^value</body></methods><methods><class-id>LDA</class-id> <category>accessing</category><body package="AssemblyInterpreter" selector="value:">value: aSymbol	value := aSymbol.	^value</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="NextAction">NextAction	| inst val dec lda ldb ldi st xch jmp jzs jvs add hlt|	PC := PC + 1.	inst := ali memory at: PC.		((inst asString) = 'DEC') 	ifTrue:[	PC := PC + 1.	val := ali memory at: PC.	dec := DEC new.	dec value: val.	dec command: self.	].	((inst asString) = 'LDA') 	ifTrue:[	PC := PC + 1.	val := ali memory at: PC.	lda := LDA new.	lda value: val.	lda command: self.	].		((inst asString) = 'LDI') 	ifTrue:[	PC := PC + 1.	val := ali memory at: PC.	ldi := LDI new.	ldi value: val.	ldi command: self.	].		^self</body></methods><methods><class-id>LDA</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGUI		| sym index|		index := 1.	(index &lt;= 256)	whileTrue:[]</body></methods><methods><class-id>LDA</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGUI		| sym index|		index := 1.	[index &lt;= 256]	whileTrue:[		((aGUI symbols at: index) = value)		ifTrue: [aGUI RegA value: (aGUI memory at: index)].		index := index + 1.		]</body></methods><methods><class-id>LDA</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGUI		| index|		index := 1.	[index &lt;= 256]	whileTrue:[		((aGUI symbols at: index) = value)		ifTrue: [aGUI RegA value: (aGUI memory at: index)].		index := index + 1.		]</body></methods><do-it>GUI open.</do-it><methods><class-id>LDA</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGUI		| index|		index := 1.	[index &lt;= 256]	whileTrue:[		((aGUI ali symbols at: index) = value)		ifTrue: [aGUI RegA value: (aGUI ali memory at: index)].		index := index + 1.		]</body></methods><do-it>GUI open.</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('c:\Users\Joey\Documents\VisualWorks Projects\Project2\Project2.im' 'March 18, 2018' '4:55:35 PM')""An image file c:\Users\Joey\Documents\VisualWorks Projects\Project2\Project2.im was created at 4:55:35 PM on March 18, 2018."</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="NextAction">NextAction	| inst val dec lda ldb ldi st xch jmp jzs jvs add hlt word aStream|	PC := PC + 1.	word := ali memory at: PC.	aStream := word readStream.	inst := aStream upToAll: ' '.		((inst asString) = 'DEC') 	ifTrue:[	PC := PC + 1.	val := ali memory at: PC.	dec := DEC new.	dec value: val.	dec command: self.	].	((inst asString) = 'LDA') 	ifTrue:[	PC := PC + 1.	val := ali memory at: PC.	lda := LDA new.	lda value: val.	lda command: self.	].		((inst asString) = 'LDI') 	ifTrue:[	PC := PC + 1.	aStream next.	val := aStream upToEnd.	"val := ali memory at: PC."	ldi := LDI new.	ldi value: val.	ldi command: self.	].		^self</body></methods><do-it>GUI open.</do-it><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="NextAction">NextAction	| inst val dec lda ldb ldi st xch jmp jzs jvs add hlt word aStream|	PC := PC + 1.	word := ali memory at: PC.	aStream := word readStream.	inst := aStream upToAll: ' '.		((inst asString) = 'DEC') 	ifTrue:[	aStream next.	val := aStream upToEnd.	dec := DEC new.	dec value: val.	dec command: self.	].	((inst asString) = 'LDA') 	ifTrue:[	aStream next.	val := aStream upToEnd.	lda := LDA new.	lda value: val.	lda command: self.	].		((inst asString) = 'LDI') 	ifTrue:[	aStream next.	val := aStream upToEnd.	ldi := LDI new.	ldi value: val.	ldi command: self.	].		^self</body></methods><do-it>GUI open.</do-it><class><name>LDB</name><environment>Smalltalk</environment><super>SAL</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AssemblyInterpreter</package></attributes></class><methods><class-id>LDB</class-id> <category>initialize-release</category><body package="AssemblyInterpreter" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>LDB</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGUI	" *** This method was defined by SAL as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><class><name>ST</name><environment>Smalltalk</environment><super>SAL</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AssemblyInterpreter</package></attributes></class><methods><class-id>ST</class-id> <category>accessing</category><body package="AssemblyInterpreter" selector="value">value	^value</body></methods><methods><class-id>ST</class-id> <category>accessing</category><body package="AssemblyInterpreter" selector="value:">value: anObject	value := anObject</body></methods><methods><class-id>ST</class-id> <category>initialize-release</category><body package="AssemblyInterpreter" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	value := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>ST</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGUI	" *** This method was defined by SAL as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><class><name>XCH</name><environment>Smalltalk</environment><super>SAL</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AssemblyInterpreter</package></attributes></class><methods><class-id>XCH</class-id> <category>initialize-release</category><body package="AssemblyInterpreter" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>XCH</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGUI	" *** This method was defined by SAL as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><class><name>JMP</name><environment>Smalltalk</environment><super>SAL</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AssemblyInterpreter</package></attributes></class><methods><class-id>JMP</class-id> <category>accessing</category><body package="AssemblyInterpreter" selector="value">value	^value</body></methods><methods><class-id>JMP</class-id> <category>accessing</category><body package="AssemblyInterpreter" selector="value:">value: anObject	value := anObject</body></methods><methods><class-id>JMP</class-id> <category>initialize-release</category><body package="AssemblyInterpreter" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	value := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>JMP</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGUI	" *** This method was defined by SAL as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><class><name>JZS</name><environment>Smalltalk</environment><super>SAL</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AssemblyInterpreter</package></attributes></class><methods><class-id>JZS</class-id> <category>accessing</category><body package="AssemblyInterpreter" selector="value">value	^value</body></methods><methods><class-id>JZS</class-id> <category>accessing</category><body package="AssemblyInterpreter" selector="value:">value: anObject	value := anObject</body></methods><methods><class-id>JZS</class-id> <category>initialize-release</category><body package="AssemblyInterpreter" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	value := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>JZS</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGUI	" *** This method was defined by SAL as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><class><name>JVS</name><environment>Smalltalk</environment><super>SAL</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AssemblyInterpreter</package></attributes></class><methods><class-id>JVS</class-id> <category>accessing</category><body package="AssemblyInterpreter" selector="value">value	^value</body></methods><methods><class-id>JVS</class-id> <category>accessing</category><body package="AssemblyInterpreter" selector="value:">value: anObject	value := anObject</body></methods><methods><class-id>JVS</class-id> <category>initialize-release</category><body package="AssemblyInterpreter" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	value := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>JVS</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGUI	" *** This method was defined by SAL as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><class><name>ADD</name><environment>Smalltalk</environment><super>SAL</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AssemblyInterpreter</package></attributes></class><methods><class-id>ADD</class-id> <category>initialize-release</category><body package="AssemblyInterpreter" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>ADD</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGUI	" *** This method was defined by SAL as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><class><name>HLT</name><environment>Smalltalk</environment><super>SAL</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AssemblyInterpreter</package></attributes></class><methods><class-id>HLT</class-id> <category>initialize-release</category><body package="AssemblyInterpreter" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>HLT</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGUI	" *** This method was defined by SAL as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><class><name>LDB</name><environment>Smalltalk</environment><super>SAL</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AssemblyInterpreter</package></attributes></class><do-it>LDB organization addCategory: #accessing</do-it><methods><class-id>LDB</class-id> <category>accessing</category><body package="AssemblyInterpreter" selector="value">value	^value</body></methods><methods><class-id>LDB</class-id> <category>accessing</category><body package="AssemblyInterpreter" selector="value:">value: aGui	^value</body></methods><methods><class-id>LDB</class-id> <category>accessing</category><body package="AssemblyInterpreter" selector="value:">value: aSymbol	value := aSymbol.	^value</body></methods><methods><class-id>LDB</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGUI		| index|		index := 1.	[index &lt;= 256]	whileTrue:[		((aGUI ali symbols at: index) = value)		ifTrue: [aGUI RegB value: (aGUI ali memory at: index)].		index := index + 1.		]</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="NextAction">NextAction	| inst val dec lda ldb ldi st xch jmp jzs jvs add hlt word aStream|	PC := PC + 1.	word := ali memory at: PC.	aStream := word readStream.	inst := aStream upToAll: ' '.		((inst asString) = 'DEC') 	ifTrue:[	aStream next.	val := aStream upToEnd.	dec := DEC new.	dec value: val.	dec command: self.	].	((inst asString) = 'LDA') 	ifTrue:[	aStream next.	val := aStream upToEnd.	lda := LDA new.	lda value: val.	lda command: self.	].	((inst asString) = 'LDB') 	ifTrue:[	aStream next.	val := aStream upToEnd.	lda := LDB new.	lda value: val.	lda command: self.	].		((inst asString) = 'LDI') 	ifTrue:[	aStream next.	val := aStream upToEnd.	ldi := LDI new.	ldi value: val.	ldi command: self.	].		^self</body></methods><do-it>GUI open.</do-it><methods><class-id>XCH</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGUI		</body></methods><methods><class-id>XCH</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGUI		| temp |	temp := aGUI ali RegA value.	aGUI ali RegA value: (aGUI ali RegB value).	aGUI ali RegB value: temp.		</body></methods><methods><class-id>XCH</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGUI		| temp |	temp := aGUI ali RegA value.	aGUI ali RegA value: (aGUI ali RegB value).	aGUI ali RegB value: temp.		^self</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="NextAction">NextAction	| inst val dec lda ldb ldi st xch jmp jzs jvs add hlt word aStream|	PC := PC + 1.	word := ali memory at: PC.	aStream := word readStream.	inst := aStream upToAll: ' '.		((inst asString) = 'DEC') 	ifTrue:[	aStream next.	val := aStream upToEnd.	dec := DEC new.	dec value: val.	dec command: self.	].	((inst asString) = 'LDA') 	ifTrue:[	aStream next.	val := aStream upToEnd.	lda := LDA new.	lda value: val.	lda command: self.	].	((inst asString) = 'LDB') 	ifTrue:[	aStream next.	val := aStream upToEnd.	lda := LDB new.	lda value: val.	lda command: self.	].		((inst asString) = 'LDI') 	ifTrue:[	aStream next.	val := aStream upToEnd.	ldi := LDI new.	ldi value: val.	ldi command: self.	].	((inst asString) = 'XCH') 	ifTrue:[	xch := XCH new.	xch command: self.	].		^self</body></methods><do-it>GUI open.</do-it><do-it>GUI open.</do-it><methods><class-id>XCH</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGUI		| temp |	temp := aGUI RegA value.	aGUI RegA value: (aGUI RegB value).	aGUI RegB value: temp.		^self</body></methods><do-it>GUI open.</do-it><do-it>GUI open.</do-it><methods><class-id>ST</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGUI			^self</body></methods><methods><class-id>ST</class-id> <category>accessing</category><body package="AssemblyInterpreter" selector="value:">value: aSymbol	value := aSymbol</body></methods><methods><class-id>ST</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGUI		| index|		index := 1.	[index &lt;= 256]	whileTrue:[		((aGUI ali symbols at: index) = value)		ifTrue: [aGUI ali memory at: index put: (aGUI RegA)].		index := index + 1.		]	</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="NextAction">NextAction	| inst val dec lda ldb ldi st xch jmp jzs jvs add hlt word aStream|	PC := PC + 1.	word := ali memory at: PC.	aStream := word readStream.	inst := aStream upToAll: ' '.		((inst asString) = 'DEC') 	ifTrue:[	aStream next.	val := aStream upToEnd.	dec := DEC new.	dec value: val.	dec command: self.	].	((inst asString) = 'LDA') 	ifTrue:[	aStream next.	val := aStream upToEnd.	lda := LDA new.	lda value: val.	lda command: self.	].	((inst asString) = 'LDB') 	ifTrue:[	aStream next.	val := aStream upToEnd.	lda := LDB new.	lda value: val.	lda command: self.	].		((inst asString) = 'LDI') 	ifTrue:[	aStream next.	val := aStream upToEnd.	ldi := LDI new.	ldi value: val.	ldi command: self.	].	((inst asString) = 'ST') 	ifTrue:[	aStream next.	val := aStream upToEnd.	st := ST new.	st value: val.	st command: self.	].	((inst asString) = 'XCH') 	ifTrue:[	xch := XCH new.	xch command: self.	].		^self</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI class</class-id> <category>interface specs</category><body package="AssemblyInterpreter" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'MyCanvas' 			#bounds: #(#{Graphics.Rectangle} 1847 374 2166 651 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 25 0 12 0 140 0 177 0 ) 					#name: #TextALI 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#model: #TextAspect 					#tabRequiresControl: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 231 0 17 0 283 0 38 0 ) 					#name: #ActionNext 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#model: #NextAction 					#label: 					#(#{Kernel.UserMessage} 						#key: #NextKey 						#defaultString: 'Next' 						#catalogID: #NextCat ) 					#style: #default 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 231 0 48 0 284 0 69 0 ) 					#name: #ActionAll 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#model: #AllAction 					#label: 					#(#{Kernel.UserMessage} 						#key: #AllKey 						#defaultString: 'All' 						#catalogID: #AllCat ) 					#style: #default 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 33 0 188 0 ) 					#name: #LblRegA 					#label: 'RegA' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 34 0 213 0 ) 					#name: #LblRegB 					#label: 'RegB' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 42 0 241 0 ) 					#name: #LblPC 					#label: 'PC' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 187 0 177 0 206 0 ) 					#name: #RegA 					#model: #RegA 					#isReadOnly: true 					#type: #string ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 78 0 213 0 178 0 232 0 ) 					#name: #RegB 					#model: #RegB 					#isReadOnly: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 79 0 237 0 179 0 256 0 ) 					#name: #PC 					#model: #PC 					#isReadOnly: true 					#type: #number ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 196 0 234 0 303 0 255 0 ) 					#name: #ActionButton1 					#model: #Load 					#label: 					#(#{Kernel.UserMessage} 						#key: #LoadintoMemory 						#defaultString: 'Load into Memory' ) 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 194 0 187 0 294 0 206 0 ) 					#name: #overflow 					#model: #overflow 					#type: #number ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 194 0 210 0 294 0 229 0 ) 					#name: #zero 					#model: #zero 					#type: #boolean ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 144 0 12 0 230 0 178 0 ) 					#name: #lstMem 					#model: #lstMem 					#useModifierKeys: true 					#selectionType: #highlight ) ) ) )</body></methods><class><name>GUI</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>TextAspect RegA RegB PC zero overflow ali lstMem </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AssemblyInterpreter</package></attributes></class><do-it>Smalltalk defineClass: #GUI	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'TextAspect RegA RegB PC zero overflow ali  lstMem '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>GUI</class-id> <category>aspects</category><body package="AssemblyInterpreter" selector="lstMem">lstMem	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^lstMem isNil		ifTrue:			[lstMem := SelectionInList new]		ifFalse:			[lstMem]</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word index|	"This stub method was generated by UIDefiner"	ali := ALI new.	index := 1.	aStream := TextAspect value readStream.	word := (aStream upTo: (Character cr)).	[aStream atEnd] whileFalse: [		ali memory at: index put: word. 		word := (aStream upTo: (Character cr)).		index := index + 1.		].	ali memory at: index put: word.	lstMem list: ali memory.		PC := 0.		^self</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI class</class-id> <category>interface specs</category><body package="AssemblyInterpreter" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'MyCanvas' 			#bounds: #(#{Graphics.Rectangle} 1847 374 2166 651 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 25 0 12 0 140 0 177 0 ) 					#name: #TextALI 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#model: #TextAspect 					#tabRequiresControl: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 149 0 13 0 201 0 34 0 ) 					#name: #ActionNext 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#model: #NextAction 					#label: 					#(#{Kernel.UserMessage} 						#key: #NextKey 						#defaultString: 'Next' 						#catalogID: #NextCat ) 					#style: #default 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 149 0 44 0 202 0 65 0 ) 					#name: #ActionAll 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#model: #AllAction 					#label: 					#(#{Kernel.UserMessage} 						#key: #AllKey 						#defaultString: 'All' 						#catalogID: #AllCat ) 					#style: #default 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 33 0 188 0 ) 					#name: #LblRegA 					#label: 'RegA' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 34 0 213 0 ) 					#name: #LblRegB 					#label: 'RegB' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 42 0 241 0 ) 					#name: #LblPC 					#label: 'PC' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 187 0 177 0 206 0 ) 					#name: #RegA 					#model: #RegA 					#isReadOnly: true 					#type: #string ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 78 0 213 0 178 0 232 0 ) 					#name: #RegB 					#model: #RegB 					#isReadOnly: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 79 0 237 0 179 0 256 0 ) 					#name: #PC 					#model: #PC 					#isReadOnly: true 					#type: #number ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 196 0 234 0 303 0 255 0 ) 					#name: #ActionButton1 					#model: #Load 					#label: 					#(#{Kernel.UserMessage} 						#key: #LoadintoMemory 						#defaultString: 'Load into Memory' ) 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 194 0 187 0 294 0 206 0 ) 					#name: #overflow 					#model: #overflow 					#type: #number ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 194 0 210 0 294 0 229 0 ) 					#name: #zero 					#model: #zero 					#type: #boolean ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 206 0 14 0 292 0 180 0 ) 					#name: #lstMem 					#model: #lstMem 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 294 0 14 0 380 0 178 0 ) 					#name: #lstSymbol 					#model: #lstSymbol 					#useModifierKeys: true 					#selectionType: #highlight ) ) ) )</body></methods><class><name>GUI</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>TextAspect RegA RegB PC zero overflow ali lstMem lstSymbol </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AssemblyInterpreter</package></attributes></class><do-it>Smalltalk defineClass: #GUI	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'TextAspect RegA RegB PC zero overflow ali lstMem  lstSymbol '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>GUI</class-id> <category>aspects</category><body package="AssemblyInterpreter" selector="lstSymbol">lstSymbol	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^lstSymbol isNil		ifTrue:			[lstSymbol := SelectionInList new]		ifFalse:			[lstSymbol]</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word index|	"This stub method was generated by UIDefiner"	ali := ALI new.	index := 1.	aStream := TextAspect value readStream.	word := (aStream upTo: (Character cr)).	[aStream atEnd] whileFalse: [		ali memory at: index put: word. 		word := (aStream upTo: (Character cr)).		index := index + 1.		].	ali memory at: index put: word.	lstMem list: ali memory.	lstSymbol list: ali symbols.		PC := 0.		^self</body></methods><do-it>GUI open.</do-it><do-it>GUI open.</do-it><methods><class-id>ST</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGUI		| index|		index := 1.	[index &lt;= 256]	whileTrue:[		((aGUI ali symbols at: index) = value)		ifTrue: [aGUI ali memory at: index put: (aGUI RegA asString)].		index := index + 1.		]</body></methods><do-it>GUI open.</do-it><methods><class-id>ST</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGUI		| index|		index := 1.	[index &lt;= 256]	whileTrue:[		((aGUI ali symbols at: index) = value)		ifTrue: [aGUI ali memory at: index put: (aGUI RegA printString)].		index := index + 1.		]</body></methods><do-it>GUI open.</do-it><methods><class-id>ST</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGUI		| index|		index := 1.	[index &lt;= 256]	whileTrue:[		((aGUI ali symbols at: index) = value)		ifTrue: [aGUI ali memory at: index put: (aGUI RegA value)].		index := index + 1.		]</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="NextAction">NextAction	| inst val dec lda ldb ldi st xch jmp jzs jvs add hlt word aStream|	PC := PC + 1.	(ali memory at: PC = nil)	ifTrue: [^ self].		word := ali memory at: PC.	aStream := word readStream.	inst := aStream upToAll: ' '.		((inst asString) = 'DEC') 	ifTrue:[	aStream next.	val := aStream upToEnd.	dec := DEC new.	dec value: val.	dec command: self.	].	((inst asString) = 'LDA') 	ifTrue:[	aStream next.	val := aStream upToEnd.	lda := LDA new.	lda value: val.	lda command: self.	].	((inst asString) = 'LDB') 	ifTrue:[	aStream next.	val := aStream upToEnd.	lda := LDB new.	lda value: val.	lda command: self.	].		((inst asString) = 'LDI') 	ifTrue:[	aStream next.	val := aStream upToEnd.	ldi := LDI new.	ldi value: val.	ldi command: self.	].	((inst asString) = 'ST') 	ifTrue:[	aStream next.	val := aStream upToEnd.	st := ST new.	st value: val.	st command: self.	].	((inst asString) = 'XCH') 	ifTrue:[	xch := XCH new.	xch command: self.	].		^self</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="NextAction">NextAction	| inst val dec lda ldb ldi st xch jmp jzs jvs add hlt word aStream|	PC := PC + 1.	((ali memory at: PC) = nil)	ifTrue: [^ self].		word := ali memory at: PC.	aStream := word readStream.	inst := aStream upToAll: ' '.		((inst asString) = 'DEC') 	ifTrue:[	aStream next.	val := aStream upToEnd.	dec := DEC new.	dec value: val.	dec command: self.	].	((inst asString) = 'LDA') 	ifTrue:[	aStream next.	val := aStream upToEnd.	lda := LDA new.	lda value: val.	lda command: self.	].	((inst asString) = 'LDB') 	ifTrue:[	aStream next.	val := aStream upToEnd.	lda := LDB new.	lda value: val.	lda command: self.	].		((inst asString) = 'LDI') 	ifTrue:[	aStream next.	val := aStream upToEnd.	ldi := LDI new.	ldi value: val.	ldi command: self.	].	((inst asString) = 'ST') 	ifTrue:[	aStream next.	val := aStream upToEnd.	st := ST new.	st value: val.	st command: self.	].	((inst asString) = 'XCH') 	ifTrue:[	xch := XCH new.	xch command: self.	].		^self</body></methods><do-it>GUI open.</do-it><do-it>GUI open.</do-it><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="NextAction">NextAction	| inst val dec lda ldb ldi st xch jmp jzs jvs add hlt word aStream|	PC := PC + 1.	PC value: PC + 1.	((ali memory at: PC) = nil)	ifTrue: [^ self].		word := ali memory at: PC.	aStream := word readStream.	inst := aStream upToAll: ' '.		((inst asString) = 'DEC') 	ifTrue:[	aStream next.	val := aStream upToEnd.	dec := DEC new.	dec value: val.	dec command: self.	].	((inst asString) = 'LDA') 	ifTrue:[	aStream next.	val := aStream upToEnd.	lda := LDA new.	lda value: val.	lda command: self.	].	((inst asString) = 'LDB') 	ifTrue:[	aStream next.	val := aStream upToEnd.	lda := LDB new.	lda value: val.	lda command: self.	].		((inst asString) = 'LDI') 	ifTrue:[	aStream next.	val := aStream upToEnd.	ldi := LDI new.	ldi value: val.	ldi command: self.	].	((inst asString) = 'ST') 	ifTrue:[	aStream next.	val := aStream upToEnd.	st := ST new.	st value: val.	st command: self.	].	((inst asString) = 'XCH') 	ifTrue:[	xch := XCH new.	xch command: self.	].		^self</body></methods><methods><class-id>GUI</class-id> <category>aspects</category><body package="AssemblyInterpreter" selector="PC">PC	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^PC isNil		ifTrue:			[PC := 0 asValue]		ifFalse:			[PC]</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word index|	"This stub method was generated by UIDefiner"	ali := ALI new.	index := 1.	aStream := TextAspect value readStream.	word := (aStream upTo: (Character cr)).	[aStream atEnd] whileFalse: [		ali memory at: index put: word. 		word := (aStream upTo: (Character cr)).		index := index + 1.		].	ali memory at: index put: word.	lstMem list: ali memory.	lstSymbol list: ali symbols.		PC := 0.	PC value: 0.		^self</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word index|	"This stub method was generated by UIDefiner"	ali := ALI new.	index := 1.	aStream := TextAspect value readStream.	word := (aStream upTo: (Character cr)).	[aStream atEnd] whileFalse: [		ali memory at: index put: word. 		word := (aStream upTo: (Character cr)).		index := index + 1.		].	ali memory at: index put: word.	lstMem list: ali memory.	lstSymbol list: ali symbols.		PC := 0.		^self</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="NextAction">NextAction	| inst val dec lda ldb ldi st xch jmp jzs jvs add hlt word aStream|	PC := PC + 1.	PC value: (PC + 1) asValue.	((ali memory at: PC) = nil)	ifTrue: [^ self].		word := ali memory at: PC.	aStream := word readStream.	inst := aStream upToAll: ' '.		((inst asString) = 'DEC') 	ifTrue:[	aStream next.	val := aStream upToEnd.	dec := DEC new.	dec value: val.	dec command: self.	].	((inst asString) = 'LDA') 	ifTrue:[	aStream next.	val := aStream upToEnd.	lda := LDA new.	lda value: val.	lda command: self.	].	((inst asString) = 'LDB') 	ifTrue:[	aStream next.	val := aStream upToEnd.	lda := LDB new.	lda value: val.	lda command: self.	].		((inst asString) = 'LDI') 	ifTrue:[	aStream next.	val := aStream upToEnd.	ldi := LDI new.	ldi value: val.	ldi command: self.	].	((inst asString) = 'ST') 	ifTrue:[	aStream next.	val := aStream upToEnd.	st := ST new.	st value: val.	st command: self.	].	((inst asString) = 'XCH') 	ifTrue:[	xch := XCH new.	xch command: self.	].		^self</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="NextAction">NextAction	| inst val dec lda ldb ldi st xch jmp jzs jvs add hlt word aStream|	PC := PC + 1.	PC value: (PC asValue).	((ali memory at: PC) = nil)	ifTrue: [^ self].		word := ali memory at: PC.	aStream := word readStream.	inst := aStream upToAll: ' '.		((inst asString) = 'DEC') 	ifTrue:[	aStream next.	val := aStream upToEnd.	dec := DEC new.	dec value: val.	dec command: self.	].	((inst asString) = 'LDA') 	ifTrue:[	aStream next.	val := aStream upToEnd.	lda := LDA new.	lda value: val.	lda command: self.	].	((inst asString) = 'LDB') 	ifTrue:[	aStream next.	val := aStream upToEnd.	lda := LDB new.	lda value: val.	lda command: self.	].		((inst asString) = 'LDI') 	ifTrue:[	aStream next.	val := aStream upToEnd.	ldi := LDI new.	ldi value: val.	ldi command: self.	].	((inst asString) = 'ST') 	ifTrue:[	aStream next.	val := aStream upToEnd.	st := ST new.	st value: val.	st command: self.	].	((inst asString) = 'XCH') 	ifTrue:[	xch := XCH new.	xch command: self.	].		^self</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="NextAction">NextAction	| inst val dec lda ldb ldi st xch jmp jzs jvs add hlt word aStream|	PC := PC + 1.	PC value: (PC value asValue).	((ali memory at: PC) = nil)	ifTrue: [^ self].		word := ali memory at: PC.	aStream := word readStream.	inst := aStream upToAll: ' '.		((inst asString) = 'DEC') 	ifTrue:[	aStream next.	val := aStream upToEnd.	dec := DEC new.	dec value: val.	dec command: self.	].	((inst asString) = 'LDA') 	ifTrue:[	aStream next.	val := aStream upToEnd.	lda := LDA new.	lda value: val.	lda command: self.	].	((inst asString) = 'LDB') 	ifTrue:[	aStream next.	val := aStream upToEnd.	lda := LDB new.	lda value: val.	lda command: self.	].		((inst asString) = 'LDI') 	ifTrue:[	aStream next.	val := aStream upToEnd.	ldi := LDI new.	ldi value: val.	ldi command: self.	].	((inst asString) = 'ST') 	ifTrue:[	aStream next.	val := aStream upToEnd.	st := ST new.	st value: val.	st command: self.	].	((inst asString) = 'XCH') 	ifTrue:[	xch := XCH new.	xch command: self.	].		^self</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="NextAction">NextAction	| inst val dec lda ldb ldi st xch jmp jzs jvs add hlt word aStream|	PC := PC + 1.	PC value: (1 asValue).	((ali memory at: PC) = nil)	ifTrue: [^ self].		word := ali memory at: PC.	aStream := word readStream.	inst := aStream upToAll: ' '.		((inst asString) = 'DEC') 	ifTrue:[	aStream next.	val := aStream upToEnd.	dec := DEC new.	dec value: val.	dec command: self.	].	((inst asString) = 'LDA') 	ifTrue:[	aStream next.	val := aStream upToEnd.	lda := LDA new.	lda value: val.	lda command: self.	].	((inst asString) = 'LDB') 	ifTrue:[	aStream next.	val := aStream upToEnd.	lda := LDB new.	lda value: val.	lda command: self.	].		((inst asString) = 'LDI') 	ifTrue:[	aStream next.	val := aStream upToEnd.	ldi := LDI new.	ldi value: val.	ldi command: self.	].	((inst asString) = 'ST') 	ifTrue:[	aStream next.	val := aStream upToEnd.	st := ST new.	st value: val.	st command: self.	].	((inst asString) = 'XCH') 	ifTrue:[	xch := XCH new.	xch command: self.	].		^self</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="NextAction">NextAction	| inst val dec lda ldb ldi st xch jmp jzs jvs add hlt word aStream|	PC := PC + 1.	PC value: (PC asNumber).	((ali memory at: PC) = nil)	ifTrue: [^ self].		word := ali memory at: PC.	aStream := word readStream.	inst := aStream upToAll: ' '.		((inst asString) = 'DEC') 	ifTrue:[	aStream next.	val := aStream upToEnd.	dec := DEC new.	dec value: val.	dec command: self.	].	((inst asString) = 'LDA') 	ifTrue:[	aStream next.	val := aStream upToEnd.	lda := LDA new.	lda value: val.	lda command: self.	].	((inst asString) = 'LDB') 	ifTrue:[	aStream next.	val := aStream upToEnd.	lda := LDB new.	lda value: val.	lda command: self.	].		((inst asString) = 'LDI') 	ifTrue:[	aStream next.	val := aStream upToEnd.	ldi := LDI new.	ldi value: val.	ldi command: self.	].	((inst asString) = 'ST') 	ifTrue:[	aStream next.	val := aStream upToEnd.	st := ST new.	st value: val.	st command: self.	].	((inst asString) = 'XCH') 	ifTrue:[	xch := XCH new.	xch command: self.	].		^self</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="NextAction">NextAction	| inst val dec lda ldb ldi st xch jmp jzs jvs add hlt word aStream|	PC := PC + 1.	PC value: (PC printString).	((ali memory at: PC) = nil)	ifTrue: [^ self].		word := ali memory at: PC.	aStream := word readStream.	inst := aStream upToAll: ' '.		((inst asString) = 'DEC') 	ifTrue:[	aStream next.	val := aStream upToEnd.	dec := DEC new.	dec value: val.	dec command: self.	].	((inst asString) = 'LDA') 	ifTrue:[	aStream next.	val := aStream upToEnd.	lda := LDA new.	lda value: val.	lda command: self.	].	((inst asString) = 'LDB') 	ifTrue:[	aStream next.	val := aStream upToEnd.	lda := LDB new.	lda value: val.	lda command: self.	].		((inst asString) = 'LDI') 	ifTrue:[	aStream next.	val := aStream upToEnd.	ldi := LDI new.	ldi value: val.	ldi command: self.	].	((inst asString) = 'ST') 	ifTrue:[	aStream next.	val := aStream upToEnd.	st := ST new.	st value: val.	st command: self.	].	((inst asString) = 'XCH') 	ifTrue:[	xch := XCH new.	xch command: self.	].		^self</body></methods><do-it>GUI open.</do-it><class><name>GUI</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>TextAspect RegA RegB PC zero overflow ali lstMem lstSymbol pc </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AssemblyInterpreter</package></attributes></class><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word index|	"This stub method was generated by UIDefiner"	ali := ALI new.	index := 1.	aStream := TextAspect value readStream.	word := (aStream upTo: (Character cr)).	[aStream atEnd] whileFalse: [		ali memory at: index put: word. 		word := (aStream upTo: (Character cr)).		index := index + 1.		].	ali memory at: index put: word.	lstMem list: ali memory.	lstSymbol list: ali symbols.		pc := 0.		^self</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="NextAction">NextAction	| inst val dec lda ldb ldi st xch jmp jzs jvs add hlt word aStream|	pc := pc + 1.	PC value: (pc printString).	((ali memory at: pc) = nil)	ifTrue: [^ self].		word := ali memory at: pc.	aStream := word readStream.	inst := aStream upToAll: ' '.		((inst asString) = 'DEC') 	ifTrue:[	aStream next.	val := aStream upToEnd.	dec := DEC new.	dec value: val.	dec command: self.	].	((inst asString) = 'LDA') 	ifTrue:[	aStream next.	val := aStream upToEnd.	lda := LDA new.	lda value: val.	lda command: self.	].	((inst asString) = 'LDB') 	ifTrue:[	aStream next.	val := aStream upToEnd.	lda := LDB new.	lda value: val.	lda command: self.	].		((inst asString) = 'LDI') 	ifTrue:[	aStream next.	val := aStream upToEnd.	ldi := LDI new.	ldi value: val.	ldi command: self.	].	((inst asString) = 'ST') 	ifTrue:[	aStream next.	val := aStream upToEnd.	st := ST new.	st value: val.	st command: self.	].	((inst asString) = 'XCH') 	ifTrue:[	xch := XCH new.	xch command: self.	].		^self</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="NextAction">NextAction	| inst val dec lda ldb ldi st xch jmp jzs jvs add hlt word aStream|	pc := pc + 1.	PC value: (pc asNumber).	((ali memory at: pc) = nil)	ifTrue: [^ self].		word := ali memory at: pc.	aStream := word readStream.	inst := aStream upToAll: ' '.		((inst asString) = 'DEC') 	ifTrue:[	aStream next.	val := aStream upToEnd.	dec := DEC new.	dec value: val.	dec command: self.	].	((inst asString) = 'LDA') 	ifTrue:[	aStream next.	val := aStream upToEnd.	lda := LDA new.	lda value: val.	lda command: self.	].	((inst asString) = 'LDB') 	ifTrue:[	aStream next.	val := aStream upToEnd.	lda := LDB new.	lda value: val.	lda command: self.	].		((inst asString) = 'LDI') 	ifTrue:[	aStream next.	val := aStream upToEnd.	ldi := LDI new.	ldi value: val.	ldi command: self.	].	((inst asString) = 'ST') 	ifTrue:[	aStream next.	val := aStream upToEnd.	st := ST new.	st value: val.	st command: self.	].	((inst asString) = 'XCH') 	ifTrue:[	xch := XCH new.	xch command: self.	].		^self</body></methods><do-it>GUI open.</do-it><methods><class-id>DEC</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGui	aGui ali symbols at: (aGui pc) put: value.		^self</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>accessing</category><body package="AssemblyInterpreter" selector="pc">pc		^pc</body></methods><do-it>GUI open.</do-it><methods><class-id>JMP</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGUI		</body></methods><methods><class-id>GUI</class-id> <category>accessing</category><body package="AssemblyInterpreter" selector="pc:">pc: aNumber	pc := aNumber</body></methods><methods><class-id>JMP</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGUI	aGUI pc: ((value asNumber) - 1).</body></methods><methods><class-id>JMP</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGUI	aGUI pc: ((value asNumber) - 1).	aGUI PC value:1 </body></methods><methods><class-id>JMP</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGUI	aGUI pc: ((value asNumber) - 1).	aGUI PC value: (aGUI pc asNumber).</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="NextAction">NextAction	| inst val dec lda ldb ldi st xch jmp jzs jvs add hlt word aStream|	pc := pc + 1.	PC value: (pc asNumber).	((ali memory at: pc) = nil)	ifTrue: [^ self].		word := ali memory at: pc.	aStream := word readStream.	inst := aStream upToAll: ' '.		((inst asString) = 'DEC') 	ifTrue:[	aStream next.	val := aStream upToEnd.	dec := DEC new.	dec value: val.	dec command: self.	].	((inst asString) = 'LDA') 	ifTrue:[	aStream next.	val := aStream upToEnd.	lda := LDA new.	lda value: val.	lda command: self.	].	((inst asString) = 'LDB') 	ifTrue:[	aStream next.	val := aStream upToEnd.	lda := LDB new.	lda value: val.	lda command: self.	].		((inst asString) = 'LDI') 	ifTrue:[	aStream next.	val := aStream upToEnd.	ldi := LDI new.	ldi value: val.	ldi command: self.	].	((inst asString) = 'ST') 	ifTrue:[	aStream next.	val := aStream upToEnd.	st := ST new.	st value: val.	st command: self.	].	((inst asString) = 'XCH') 	ifTrue:[	xch := XCH new.	xch command: self.	].	((inst asString) = 'JMP') 	ifTrue:[	aStream next.	val := aStream upToEnd.	jmp := JMP new.	jmp value: val.	jmp command: self.	].		^self</body></methods><do-it>GUI open.</do-it><do-it>GUI open.</do-it><methods><class-id>JMP</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGUI	aGUI pc: (value asNumber).	aGUI PC value: (aGUI pc asNumber).</body></methods><do-it>GUI open.</do-it><methods><class-id>LDI</class-id> <category>accessing</category><body package="AssemblyInterpreter" selector="value:">value: aNumber	value := aNumber asSmallInteger.	^value</body></methods><methods><class-id>LDI</class-id> <category>accessing</category><body package="AssemblyInterpreter" selector="value:">value: aNumber	value := aNumber asSmallInteger.</body></methods><class><name>GUI</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>TextAspect RegA RegB PC zero overflow ali lstMem lstSymbol pc zeroVal </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AssemblyInterpreter</package></attributes></class><class><name>GUI</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>TextAspect RegA RegB PC zero overflow ali lstMem lstSymbol pc zeroVal ovfValue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AssemblyInterpreter</package></attributes></class><methods><class-id>GUI</class-id> <category>accessing</category><body package="AssemblyInterpreter" selector="ovfValue">ovfValue	^ovfValue</body></methods><methods><class-id>GUI</class-id> <category>accessing</category><body package="AssemblyInterpreter" selector="ovfValue:">ovfValue: aBool	ovfValue := aBool.</body></methods><methods><class-id>GUI</class-id> <category>accessing</category><body package="AssemblyInterpreter" selector="zeroVal">zeroVal	^zeroVal</body></methods><methods><class-id>GUI</class-id> <category>accessing</category><body package="AssemblyInterpreter" selector="zeroVal:">zeroVal: aBool	zeroVal := aBool.</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word index|	"This stub method was generated by UIDefiner"	ali := ALI new.	index := 1.	aStream := TextAspect value readStream.	word := (aStream upTo: (Character cr)).	[aStream atEnd] whileFalse: [		ali memory at: index put: word. 		word := (aStream upTo: (Character cr)).		index := index + 1.		].	ali memory at: index put: word.	lstMem list: ali memory.	lstSymbol list: ali symbols.		pc := 0.	zeroVal := false.	ovfValue := false.		^self</body></methods><methods><class-id>GUI</class-id> <category>aspects</category><body package="AssemblyInterpreter" selector="zero">zero	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^zero isNil		ifTrue:			[zero := false asValue]		ifFalse:			[zero]</body></methods><methods><class-id>GUI class</class-id> <category>interface specs</category><body package="AssemblyInterpreter" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'MyCanvas' 			#bounds: #(#{Graphics.Rectangle} 1847 374 2166 651 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 25 0 12 0 140 0 177 0 ) 					#name: #TextALI 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#model: #TextAspect 					#tabRequiresControl: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 149 0 13 0 201 0 34 0 ) 					#name: #ActionNext 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#model: #NextAction 					#label: 					#(#{Kernel.UserMessage} 						#key: #NextKey 						#defaultString: 'Next' 						#catalogID: #NextCat ) 					#style: #default 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 149 0 44 0 202 0 65 0 ) 					#name: #ActionAll 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#model: #AllAction 					#label: 					#(#{Kernel.UserMessage} 						#key: #AllKey 						#defaultString: 'All' 						#catalogID: #AllCat ) 					#style: #default 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 33 0 188 0 ) 					#name: #LblRegA 					#label: 'RegA' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 34 0 213 0 ) 					#name: #LblRegB 					#label: 'RegB' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 42 0 241 0 ) 					#name: #LblPC 					#label: 'PC' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 187 0 177 0 206 0 ) 					#name: #RegA 					#model: #RegA 					#isReadOnly: true 					#type: #string ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 78 0 213 0 178 0 232 0 ) 					#name: #RegB 					#model: #RegB 					#isReadOnly: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 79 0 237 0 179 0 256 0 ) 					#name: #PC 					#model: #PC 					#isReadOnly: true 					#type: #number ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 196 0 234 0 303 0 255 0 ) 					#name: #ActionButton1 					#model: #Load 					#label: 					#(#{Kernel.UserMessage} 						#key: #LoadintoMemory 						#defaultString: 'Load into Memory' ) 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 194 0 187 0 294 0 206 0 ) 					#name: #overflow 					#model: #overflow 					#type: #boolean ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 194 0 210 0 294 0 229 0 ) 					#name: #zero 					#model: #zero 					#type: #boolean ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 206 0 14 0 292 0 180 0 ) 					#name: #lstMem 					#model: #lstMem 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 294 0 14 0 380 0 178 0 ) 					#name: #lstSymbol 					#model: #lstSymbol 					#useModifierKeys: true 					#selectionType: #highlight ) ) ) )</body></methods><class><name>GUI</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>TextAspect RegA RegB PC zero overflow ali lstMem lstSymbol pc zeroVal ovfValue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AssemblyInterpreter</package></attributes></class><do-it>Smalltalk defineClass: #GUI	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'TextAspect RegA RegB PC zero overflow ali lstMem lstSymbol pc zeroVal ovfValue  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>GUI</class-id> <category>aspects</category><body package="AssemblyInterpreter" selector="overflow">overflow	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^overflow isNil		ifTrue:			[overflow := true asValue]		ifFalse:			[overflow]</body></methods><methods><class-id>GUI</class-id> <category>aspects</category><body package="AssemblyInterpreter" selector="overflow">overflow	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^overflow isNil		ifTrue:			[overflow := false asValue]		ifFalse:			[overflow]</body></methods><do-it>GUI open.</do-it><methods><class-id>LDI</class-id> <category>accessing</category><body package="AssemblyInterpreter" selector="value:">value: aNumber	| temp |	temp := aNumber asValue.	value := temp asSmallInteger.</body></methods><do-it>GUI open.</do-it><methods><class-id>LDI</class-id> <category>accessing</category><body package="AssemblyInterpreter" selector="value:">value: aNumber	value := aNumber asSmallInteger.</body></methods><methods><class-id>LDI</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGui	aGui RegA value: value.</body></methods><do-it>GUI open.</do-it><methods><class-id>LDI</class-id> <category>accessing</category><body package="AssemblyInterpreter" selector="value:">value: aNumber	| temp |	temp := aNumber asValue.	value := temp asSmallInteger.</body></methods><do-it>GUI open.</do-it><methods><class-id>LDI</class-id> <category>accessing</category><body package="AssemblyInterpreter" selector="value:">value: aNumber	| temp |	temp := aNumber asValue.	value := temp value asSmallInteger.</body></methods><do-it>GUI open.</do-it><methods><class-id>LDI</class-id> <category>accessing</category><body package="AssemblyInterpreter" selector="value:">value: aNumber	| temp |	temp := aNumber asValue.	value := ((temp value) asSmallInteger).</body></methods><do-it>GUI open.</do-it><methods><class-id>LDI</class-id> <category>accessing</category><body package="AssemblyInterpreter" selector="value:">value: aNumber	| temp |	temp := aNumber asNumber.	value := temp asSmallInteger.</body></methods><do-it>GUI open.</do-it><do-it>GUI open.</do-it><methods><class-id>LDI</class-id> <category>accessing</category><body package="AssemblyInterpreter" selector="value:">value: aNumber	value := aNumber asValue.</body></methods><do-it>GUI open.</do-it><methods><class-id>LDI</class-id> <category>accessing</category><body package="AssemblyInterpreter" selector="value:">value: aNumber	value := aNumber asNumber.</body></methods><do-it>GUI open.</do-it><methods><class-id>LDI</class-id> <category>accessing</category><body package="AssemblyInterpreter" selector="value:">value: aNumber	value := aNumber.</body></methods><do-it>GUI open.</do-it><methods><class-id>ADD</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGUI		| tmpa tmpb rega regb |	tmpa := aGUI RegA value asNumber.	tmpb := aGUI RegB value asNumber.	rega := tmpa asSmallInteger.	regb := tmpb asSmallInteger.		aGUI RegA value: ((rega + regb) asString).</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="NextAction">NextAction	| inst val dec lda ldb ldi st xch jmp jzs jvs add hlt word aStream|	pc := pc + 1.	PC value: (pc asNumber).	((ali memory at: pc) = nil)	ifTrue: [^ self].		word := ali memory at: pc.	aStream := word readStream.	inst := aStream upToAll: ' '.		((inst asString) = 'DEC') 	ifTrue:[	aStream next.	val := aStream upToEnd.	dec := DEC new.	dec value: val.	dec command: self.	].	((inst asString) = 'LDA') 	ifTrue:[	aStream next.	val := aStream upToEnd.	lda := LDA new.	lda value: val.	lda command: self.	].	((inst asString) = 'LDB') 	ifTrue:[	aStream next.	val := aStream upToEnd.	lda := LDB new.	lda value: val.	lda command: self.	].		((inst asString) = 'LDI') 	ifTrue:[	aStream next.	val := aStream upToEnd.	ldi := LDI new.	ldi value: val.	ldi command: self.	].	((inst asString) = 'ST') 	ifTrue:[	aStream next.	val := aStream upToEnd.	st := ST new.	st value: val.	st command: self.	].	((inst asString) = 'XCH') 	ifTrue:[	xch := XCH new.	xch command: self.	].	((inst asString) = 'JMP') 	ifTrue:[	aStream next.	val := aStream upToEnd.	jmp := JMP new.	jmp value: val.	jmp command: self.	].	((inst asString) = 'ADD') 	ifTrue:[	add := ADD new.	add command: self.	].		^self</body></methods><do-it>GUI open.</do-it><do-it>GUI open.</do-it><methods><class-id>ADD</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGUI		| tmpa tmpb rega regb |	tmpa := aGUI RegA value asNumber.	tmpb := aGUI RegB value asNumber.	rega := tmpa asSmallInteger.	regb := tmpb asSmallInteger.		aGUI RegA value: ((rega + regb) printString).</body></methods><do-it>GUI open.</do-it><methods><class-id>ADD</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGUI		| sum tmpa tmpb rega regb |	tmpa := aGUI RegA value asNumber.	tmpb := aGUI RegB value asNumber.	rega := tmpa asSmallInteger.	regb := tmpb asSmallInteger.	sum := rega + regb.	aGUI ovfValue: false.	aGUI overflow value: false.			(rega &gt; 0)	ifTrue: [(regb &gt; 0)			ifTrue: [(sum &lt; 0)					ifTrue: [aGUI ovfValue: true.						    aGUI overflow value: true.]]].		(rega &lt; 0)	ifTrue: [(regb &lt; 0)			ifTrue: [(sum &gt; 0)					ifTrue: [aGUI ovfValue: true.						    aGUI overflow value: true.]]].		aGUI RegA value: (sum printString).</body></methods><do-it>GUI open.</do-it><do-it>SmallInteger</do-it><do-it>SmallInteger</do-it><do-it>SmallInteger</do-it><methods><class-id>ADD</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGUI		| sum tmpa tmpb rega regb |	tmpa := aGUI RegA value asNumber.	tmpb := aGUI RegB value asNumber.	rega := tmpa asSmallInteger.	regb := tmpb asSmallInteger.	sum := rega + regb.	aGUI ovfValue: false.	aGUI overflow value: false.		(sum &gt; 536870911)	ifTrue: [		aGUI ovfValue: true.		aGUI overflow value: true.].		(sum &lt; -536870912)	ifTrue: [		aGUI ovfValue: true.		aGUI overflow value: true.].		aGUI RegA value: (sum printString).</body></methods><do-it>GUI open.</do-it><do-it>GUI open.</do-it><methods><class-id>GUI class</class-id> <category>interface specs</category><body package="AssemblyInterpreter" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'MyCanvas' 			#bounds: #(#{Graphics.Rectangle} 1906 416 2225 693 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 8 0 105 0 174 0 ) 					#name: #TextALI 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#model: #TextAspect 					#tabRequiresControl: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 111 0 115 0 163 0 136 0 ) 					#name: #ActionNext 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#model: #NextAction 					#label: 					#(#{Kernel.UserMessage} 						#key: #NextKey 						#defaultString: 'Next' 						#catalogID: #NextCat ) 					#style: #default 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 111 0 87 0 164 0 108 0 ) 					#name: #ActionAll 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#model: #AllAction 					#label: 					#(#{Kernel.UserMessage} 						#key: #AllKey 						#defaultString: 'All' 						#catalogID: #AllCat ) 					#style: #default 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 9 0 188 0 ) 					#name: #LblRegA 					#label: 'RegA' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 9 0 213 0 ) 					#name: #LblRegB 					#label: 'RegB' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 11 0 239 0 ) 					#name: #LblPC 					#label: 'PC' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 45 0 187 0 145 0 206 0 ) 					#name: #RegA 					#model: #RegA 					#isReadOnly: true 					#type: #string ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 44 0 213 0 144 0 232 0 ) 					#name: #RegB 					#model: #RegB 					#isReadOnly: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 45 0 239 0 145 0 258 0 ) 					#name: #PC 					#model: #PC 					#isReadOnly: true 					#type: #number ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 109 0 12 0 216 0 33 0 ) 					#name: #ActionButton1 					#model: #Load 					#label: 					#(#{Kernel.UserMessage} 						#key: #LoadintoMemory 						#defaultString: 'Load into Memory' ) 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 293 0 235 0 393 0 254 0 ) 					#name: #overflow 					#model: #overflow 					#isReadOnly: true 					#type: #boolean ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 293 0 255 0 393 0 274 0 ) 					#name: #zero 					#model: #zero 					#isReadOnly: true 					#type: #boolean ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 234 0 53 0 320 0 219 0 ) 					#name: #lstMem 					#model: #lstMem 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 325 0 55 0 411 0 219 0 ) 					#name: #lstSymbol 					#model: #lstSymbol 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 236 0 29 0 ) 					#name: #Label1 					#label: 'Memory' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 324 0 28 0 ) 					#name: #Label2 					#label: 'Memory' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 260 0 257 0 ) 					#name: #Label3 					#label: 'Zero?' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 236 0 237 0 ) 					#name: #Label4 					#label: 'Overflow?' ) ) ) )</body></methods><methods><class-id>GUI class</class-id> <category>interface specs</category><body package="AssemblyInterpreter" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'MyCanvas' 			#bounds: #(#{Graphics.Rectangle} 1906 416 2225 693 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 8 0 105 0 174 0 ) 					#name: #TextALI 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#model: #TextAspect 					#tabRequiresControl: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 111 0 115 0 163 0 136 0 ) 					#name: #ActionNext 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#model: #NextAction 					#label: 					#(#{Kernel.UserMessage} 						#key: #NextKey 						#defaultString: 'Next' 						#catalogID: #NextCat ) 					#style: #default 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 111 0 87 0 164 0 108 0 ) 					#name: #ActionAll 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#model: #AllAction 					#label: 					#(#{Kernel.UserMessage} 						#key: #AllKey 						#defaultString: 'All' 						#catalogID: #AllCat ) 					#style: #default 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 9 0 188 0 ) 					#name: #LblRegA 					#label: 'RegA' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 9 0 213 0 ) 					#name: #LblRegB 					#label: 'RegB' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 11 0 239 0 ) 					#name: #LblPC 					#label: 'PC' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 45 0 187 0 145 0 206 0 ) 					#name: #RegA 					#model: #RegA 					#isReadOnly: true 					#type: #string ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 44 0 213 0 144 0 232 0 ) 					#name: #RegB 					#model: #RegB 					#isReadOnly: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 45 0 239 0 145 0 258 0 ) 					#name: #PC 					#model: #PC 					#isReadOnly: true 					#type: #number ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 109 0 12 0 216 0 33 0 ) 					#name: #ActionButton1 					#model: #Load 					#label: 					#(#{Kernel.UserMessage} 						#key: #LoadintoMemory 						#defaultString: 'Load into Memory' ) 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 293 0 235 0 393 0 254 0 ) 					#name: #overflow 					#model: #overflow 					#isReadOnly: true 					#type: #boolean ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 293 0 255 0 393 0 274 0 ) 					#name: #zero 					#model: #zero 					#isReadOnly: true 					#type: #boolean ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 234 0 53 0 320 0 219 0 ) 					#name: #lstMem 					#model: #lstMem 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 325 0 55 0 411 0 219 0 ) 					#name: #lstSymbol 					#model: #lstSymbol 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 236 0 29 0 ) 					#name: #Label1 					#label: 'Memory' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 324 0 28 0 ) 					#name: #Label2 					#label: 'Memory' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 260 0 257 0 ) 					#name: #Label3 					#label: 'Zero?' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 236 0 237 0 ) 					#name: #Label4 					#label: 'Overflow?' ) ) ) )</body></methods><methods><class-id>GUI class</class-id> <category>interface specs</category><body package="AssemblyInterpreter" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #sizeType #lastSavedSize #positionType #positionSystemDefault #openType #advanced #sizeAutoSave true ) 			#label: 'MyCanvas' 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 2001 503 2320 780 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 8 0 105 0 174 0 ) 					#name: #TextALI 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#model: #TextAspect 					#tabRequiresControl: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 111 0 115 0 163 0 136 0 ) 					#name: #ActionNext 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#model: #NextAction 					#label: 					#(#{Kernel.UserMessage} 						#key: #NextKey 						#defaultString: 'Next' 						#catalogID: #NextCat ) 					#style: #default 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 111 0 87 0 164 0 108 0 ) 					#name: #ActionAll 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#model: #AllAction 					#label: 					#(#{Kernel.UserMessage} 						#key: #AllKey 						#defaultString: 'All' 						#catalogID: #AllCat ) 					#style: #default 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 9 0 188 0 ) 					#name: #LblRegA 					#label: 'RegA' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 9 0 213 0 ) 					#name: #LblRegB 					#label: 'RegB' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 11 0 239 0 ) 					#name: #LblPC 					#label: 'PC' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 45 0 187 0 145 0 206 0 ) 					#name: #RegA 					#model: #RegA 					#isReadOnly: true 					#type: #string ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 44 0 213 0 144 0 232 0 ) 					#name: #RegB 					#model: #RegB 					#isReadOnly: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 45 0 239 0 145 0 258 0 ) 					#name: #PC 					#model: #PC 					#isReadOnly: true 					#type: #number ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 109 0 12 0 216 0 33 0 ) 					#name: #ActionButton1 					#model: #Load 					#label: 					#(#{Kernel.UserMessage} 						#key: #LoadintoMemory 						#defaultString: 'Load into Memory' ) 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 293 0 235 0 393 0 254 0 ) 					#name: #overflow 					#model: #overflow 					#isReadOnly: true 					#type: #boolean ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 293 0 255 0 393 0 274 0 ) 					#name: #zero 					#model: #zero 					#isReadOnly: true 					#type: #boolean ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 234 0 53 0 320 0 219 0 ) 					#name: #lstMem 					#model: #lstMem 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 325 0 55 0 411 0 219 0 ) 					#name: #lstSymbol 					#model: #lstSymbol 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 236 0 29 0 ) 					#name: #Label1 					#label: 'Memory' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 324 0 28 0 ) 					#name: #Label2 					#label: 'Memory' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 260 0 257 0 ) 					#name: #Label3 					#label: 'Zero?' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 236 0 237 0 ) 					#name: #Label4 					#label: 'Overflow?' ) ) ) )</body></methods><methods><class-id>GUI class</class-id> <category>interface specs</category><body package="AssemblyInterpreter" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #sizeType #specifiedSize #positionType #positionSystemDefault #openType #advanced ) 			#label: 'MyCanvas' 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 2001 503 2451 803 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 8 0 105 0 174 0 ) 					#name: #TextALI 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#model: #TextAspect 					#tabRequiresControl: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 111 0 115 0 163 0 136 0 ) 					#name: #ActionNext 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#model: #NextAction 					#label: 					#(#{Kernel.UserMessage} 						#key: #NextKey 						#defaultString: 'Next' 						#catalogID: #NextCat ) 					#style: #default 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 111 0 87 0 164 0 108 0 ) 					#name: #ActionAll 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#model: #AllAction 					#label: 					#(#{Kernel.UserMessage} 						#key: #AllKey 						#defaultString: 'All' 						#catalogID: #AllCat ) 					#style: #default 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 9 0 188 0 ) 					#name: #LblRegA 					#label: 'RegA' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 9 0 213 0 ) 					#name: #LblRegB 					#label: 'RegB' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 11 0 239 0 ) 					#name: #LblPC 					#label: 'PC' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 45 0 187 0 145 0 206 0 ) 					#name: #RegA 					#model: #RegA 					#isReadOnly: true 					#type: #string ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 44 0 213 0 144 0 232 0 ) 					#name: #RegB 					#model: #RegB 					#isReadOnly: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 45 0 239 0 145 0 258 0 ) 					#name: #PC 					#model: #PC 					#isReadOnly: true 					#type: #number ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 109 0 12 0 216 0 33 0 ) 					#name: #ActionButton1 					#model: #Load 					#label: 					#(#{Kernel.UserMessage} 						#key: #LoadintoMemory 						#defaultString: 'Load into Memory' ) 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 293 0 235 0 393 0 254 0 ) 					#name: #overflow 					#model: #overflow 					#isReadOnly: true 					#type: #boolean ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 293 0 255 0 393 0 274 0 ) 					#name: #zero 					#model: #zero 					#isReadOnly: true 					#type: #boolean ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 234 0 53 0 320 0 219 0 ) 					#name: #lstMem 					#model: #lstMem 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 325 0 55 0 411 0 219 0 ) 					#name: #lstSymbol 					#model: #lstSymbol 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 236 0 29 0 ) 					#name: #Label1 					#label: 'Memory' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 324 0 28 0 ) 					#name: #Label2 					#label: 'Memory' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 260 0 257 0 ) 					#name: #Label3 					#label: 'Zero?' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 236 0 237 0 ) 					#name: #Label4 					#label: 'Overflow?' ) ) ) )</body></methods><do-it>GUI open.</do-it><methods><class-id>JZS</class-id> <category>accessing</category><body package="AssemblyInterpreter" selector="value:">value: aNumber	value := aNumber</body></methods><methods><class-id>JZS</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGUI		</body></methods><methods><class-id>JZS</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGUI	(aGUI zeroVal = true)	ifTrue:[		aGUI pc: (value asNumber).		aGUI PC value: (aGUI pc asNumber).		]	</body></methods><methods><class-id>JVS</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGUI	(aGUI ovfValue = true)	ifTrue:[		aGUI pc: (value asNumber).		aGUI PC value: (aGUI pc asNumber).		]</body></methods><methods><class-id>JVS</class-id> <category>accessing</category><body package="AssemblyInterpreter" selector="value:">value: aNumber	value := aNumber</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="NextAction">NextAction	| inst val dec lda ldb ldi st xch jmp jzs jvs add hlt word aStream|	pc := pc + 1.	PC value: (pc asNumber).	((ali memory at: pc) = nil)	ifTrue: [^ self].		word := ali memory at: pc.	aStream := word readStream.	inst := aStream upToAll: ' '.		((inst asString) = 'DEC') 	ifTrue:[	aStream next.	val := aStream upToEnd.	dec := DEC new.	dec value: val.	dec command: self.	].	((inst asString) = 'LDA') 	ifTrue:[	aStream next.	val := aStream upToEnd.	lda := LDA new.	lda value: val.	lda command: self.	].	((inst asString) = 'LDB') 	ifTrue:[	aStream next.	val := aStream upToEnd.	lda := LDB new.	lda value: val.	lda command: self.	].		((inst asString) = 'LDI') 	ifTrue:[	aStream next.	val := aStream upToEnd.	ldi := LDI new.	ldi value: val.	ldi command: self.	].	((inst asString) = 'ST') 	ifTrue:[	aStream next.	val := aStream upToEnd.	st := ST new.	st value: val.	st command: self.	].	((inst asString) = 'XCH') 	ifTrue:[	xch := XCH new.	xch command: self.	].	((inst asString) = 'JMP') 	ifTrue:[	aStream next.	val := aStream upToEnd.	jmp := JMP new.	jmp value: val.	jmp command: self.	].	((inst asString) = 'JZS') 	ifTrue:[	aStream next.	val := aStream upToEnd.	jzs := JZS new.	jzs value: val.	jzs command: self.	].	((inst asString) = 'JVS') 	ifTrue:[	aStream next.	val := aStream upToEnd.	jvs := JVS new.	jvs value: val.	jvs command: self.	].	((inst asString) = 'ADD') 	ifTrue:[	add := ADD new.	add command: self.	].		^self</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="NextAction">NextAction	| inst val dec lda ldb ldi st xch jmp jzs jvs add hlt word aStream|	pc := pc + 1.	PC value: (pc asNumber).	((ali memory at: pc) = nil)	ifTrue: [^ self].		word := ali memory at: pc.	aStream := word readStream.	inst := aStream upToAll: ' '.		((inst asString) = 'DEC') 	ifTrue:[	aStream next.	val := aStream upToEnd.	dec := DEC new.	dec value: val.	dec command: self.	].	((inst asString) = 'LDA') 	ifTrue:[	aStream next.	val := aStream upToEnd.	lda := LDA new.	lda value: val.	lda command: self.	].	((inst asString) = 'LDB') 	ifTrue:[	aStream next.	val := aStream upToEnd.	ldb := LDB new.	ldb value: val.	ldb command: self.	].		((inst asString) = 'LDI') 	ifTrue:[	aStream next.	val := aStream upToEnd.	ldi := LDI new.	ldi value: val.	ldi command: self.	].	((inst asString) = 'ST') 	ifTrue:[	aStream next.	val := aStream upToEnd.	st := ST new.	st value: val.	st command: self.	].	((inst asString) = 'XCH') 	ifTrue:[	xch := XCH new.	xch command: self.	].	((inst asString) = 'JMP') 	ifTrue:[	aStream next.	val := aStream upToEnd.	jmp := JMP new.	jmp value: val.	jmp command: self.	].	((inst asString) = 'JZS') 	ifTrue:[	aStream next.	val := aStream upToEnd.	jzs := JZS new.	jzs value: val.	jzs command: self.	].	((inst asString) = 'JVS') 	ifTrue:[	aStream next.	val := aStream upToEnd.	jvs := JVS new.	jvs value: val.	jvs command: self.	].	((inst asString) = 'ADD') 	ifTrue:[	add := ADD new.	add command: self.	].		^self</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="NextAction">NextAction	| inst val dec lda ldb ldi st xch jmp jzs jvs add hlt word aStream|	pc := pc + 1.	PC value: (pc asNumber).	((ali memory at: pc) = nil)	ifTrue: [^ self].		word := ali memory at: pc.	aStream := word readStream.	inst := aStream upToAll: ' '.		((inst asString) = 'DEC') 	ifTrue:[	aStream next.	val := aStream upToEnd.	dec := DEC new.	dec value: val.	dec command: self.	].	((inst asString) = 'LDA') 	ifTrue:[	aStream next.	val := aStream upToEnd.	lda := LDA new.	lda value: val.	lda command: self.	].	((inst asString) = 'LDB') 	ifTrue:[	aStream next.	val := aStream upToEnd.	ldb := LDB new.	ldb value: val.	ldb command: self.	].		((inst asString) = 'LDI') 	ifTrue:[	aStream next.	val := aStream upToEnd.	ldi := LDI new.	ldi value: val.	ldi command: self.	].	((inst asString) = 'ST') 	ifTrue:[	aStream next.	val := aStream upToEnd.	st := ST new.	st value: val.	st command: self.	].	((inst asString) = 'XCH') 	ifTrue:[	xch := XCH new.	xch command: self.	].	((inst asString) = 'JMP') 	ifTrue:[	aStream next.	val := aStream upToEnd.	jmp := JMP new.	jmp value: val.	jmp command: self.	].	((inst asString) = 'JZS') 	ifTrue:[	aStream next.	val := aStream upToEnd.	jzs := JZS new.	jzs value: val.	jzs command: self.	].	((inst asString) = 'JVS') 	ifTrue:[	aStream next.	val := aStream upToEnd.	jvs := JVS new.	jvs value: val.	jvs command: self.	].	((inst asString) = 'ADD') 	ifTrue:[	add := ADD new.	add command: self.	].	((inst asString) = 'HLT') 	ifTrue:[	hlt := HLT new.	hlt command: self.	].		^self</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="AllAction">AllAction	"(pc ~= 0)	ifTrue:[		(ali memory at: pc)		]"	^self</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="AllAction">AllAction	| word aStream inst |	(pc ~= 0)	ifTrue:[		word := ali memory at: pc.		aStream := word readStream.		inst := aStream upToAll: ' '.		(inst = 'HLT')		ifFalse:[			NextAction.			].		].	^self</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="AllAction">AllAction	| word aStream inst |	(pc ~= 0)	ifTrue:[		word := ali memory at: pc.		aStream := word readStream.		inst := aStream upToAll: ' '.		(inst = 'HLT')		ifFalse:[			NextAction.			].		]	ifFalse:[				].			^self</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="AllAction">AllAction	| word aStream inst |	(pc ~= 0)	ifTrue:[		word := ali memory at: pc.		aStream := word readStream.		inst := aStream upToAll: ' '.		(inst asString = 'HLT')		ifFalse:[			NextAction.			].		]	ifFalse:[				].			^self</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="AllAction">AllAction	| word aStream inst |	(pc ~= 0)	ifTrue:[		word := ali memory at: pc.		aStream := word readStream.		inst := aStream upToAll: ' '.		(inst asString = 'HLT')		]	ifFalse:[				].			^self</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="AllAction">AllAction	| word aStream inst |	(pc ~= 0)	ifTrue:[		word := ali memory at: pc.		aStream := word readStream.		inst := aStream upToAll: ' '.		(inst asString = 'HLT')		ifFalse:[			NextAction.			]		]	ifFalse:[				].			^self</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="AllAction">AllAction	| word aStream inst |	(pc ~= 0)	ifTrue:[		word := ali memory at: pc.		aStream := word readStream.		inst := aStream upToAll: ' '.		(inst asString = 'HLT')		ifFalse:[			ActionNext.			]		]	ifFalse:[				].			^self</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="AllAction">AllAction	| word aStream inst |		(pc ~= 0)	ifTrue:[		word := ali memory at: pc.		aStream := word readStream.		inst := aStream upToAll: ' '.		(inst asString = 'HLT')		ifFalse:[			self NextAction.			]		]	ifFalse:[				].			^self</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="AllAction">AllAction	| word aStream inst |		(pc ~= 0)	ifTrue:[		word := ali memory at: pc.		aStream := word readStream.		inst := aStream upToAll: ' '.		(inst asString = 'HLT')		ifFalse:[			self NextAction.			]		]	ifFalse:[		self NextAction.		].			^self</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="AllAction">AllAction	| word aStream inst |		(pc ~= 0)	ifTrue:[		[pc &lt;= 256]		whileTrue:[			word := ali memory at: pc.			aStream := word readStream.			inst := aStream upToAll: ' '.			(inst asString = 'HLT')			ifFalse:[				self NextAction.				]			]		]	ifFalse:[		self NextAction.		[pc &lt;= 256]		whileTrue:[			word := ali memory at: pc.			aStream := word readStream.			inst := aStream upToAll: ' '.			(inst asString = 'HLT')			ifFalse:[				self NextAction.				]			]		].			^self</body></methods><methods><class-id>HLT</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGUI		</body></methods><methods><class-id>HLT</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGUI	</body></methods><do-it>GUI open.</do-it><do-it>GUI open.</do-it><do-it>GUI open.</do-it><methods><class-id>GUI class</class-id> <category>interface specs</category><body package="AssemblyInterpreter" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #sizeType #specifiedSize #positionType #positionSystemDefault #openType #advanced ) 			#label: 'MyCanvas' 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 1781 362 2231 662 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 8 0 105 0 174 0 ) 					#name: #TextALI 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#model: #TextAspect 					#tabRequiresControl: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 111 0 115 0 163 0 136 0 ) 					#name: #ActionNext 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#model: #NextAction 					#label: 					#(#{Kernel.UserMessage} 						#key: #NextKey 						#defaultString: 'Next' 						#catalogID: #NextCat ) 					#style: #default 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 111 0 87 0 164 0 108 0 ) 					#name: #ActionAll 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#model: #AllAction 					#label: 					#(#{Kernel.UserMessage} 						#key: #AllKey 						#defaultString: 'All' 						#catalogID: #AllCat ) 					#style: #default 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 9 0 188 0 ) 					#name: #LblRegA 					#label: 'RegA' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 9 0 213 0 ) 					#name: #LblRegB 					#label: 'RegB' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 11 0 239 0 ) 					#name: #LblPC 					#label: 'PC' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 45 0 187 0 145 0 206 0 ) 					#name: #RegA 					#model: #RegA 					#isReadOnly: true 					#type: #string ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 44 0 213 0 144 0 232 0 ) 					#name: #RegB 					#model: #RegB 					#isReadOnly: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 45 0 239 0 145 0 258 0 ) 					#name: #PC 					#model: #PC 					#isReadOnly: true 					#type: #number ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 109 0 12 0 216 0 33 0 ) 					#name: #ActionButton1 					#model: #Load 					#label: 					#(#{Kernel.UserMessage} 						#key: #LoadintoMemory 						#defaultString: 'Load into Memory' ) 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 293 0 235 0 393 0 254 0 ) 					#name: #overflow 					#model: #overflow 					#isReadOnly: true 					#type: #boolean ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 293 0 255 0 393 0 274 0 ) 					#name: #zero 					#model: #zero 					#isReadOnly: true 					#type: #boolean ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 256 0 53 0 342 0 219 0 ) 					#name: #lstMem 					#model: #lstMem 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 349 0 55 0 435 0 219 0 ) 					#name: #lstSymbol 					#model: #lstSymbol 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 257 0 31 0 ) 					#name: #Label1 					#label: 'Memory' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 349 0 30 0 ) 					#name: #Label2 					#label: 'Symbols' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 260 0 257 0 ) 					#name: #Label3 					#label: 'Zero?' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 236 0 237 0 ) 					#name: #Label4 					#label: 'Overflow?' ) ) ) )</body></methods><methods><class-id>GUI class</class-id> <category>interface specs</category><body package="AssemblyInterpreter" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #sizeType #specifiedSize #positionType #positionSystemDefault #openType #advanced ) 			#label: 'MyCanvas' 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 1781 362 2231 662 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 6 0 10 0 134 0 172 0 ) 					#name: #TextALI 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#model: #TextAspect 					#tabRequiresControl: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 138 0 72 0 190 0 93 0 ) 					#name: #ActionNext 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#model: #NextAction 					#label: 					#(#{Kernel.UserMessage} 						#key: #NextKey 						#defaultString: 'Next' 						#catalogID: #NextCat ) 					#style: #default 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 138 0 102 0 191 0 123 0 ) 					#name: #ActionAll 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #salmon ) ) 					#model: #AllAction 					#label: 					#(#{Kernel.UserMessage} 						#key: #AllKey 						#defaultString: 'All' 						#catalogID: #AllCat ) 					#style: #default 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 9 0 188 0 ) 					#name: #LblRegA 					#label: 'RegA' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 9 0 213 0 ) 					#name: #LblRegB 					#label: 'RegB' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 11 0 239 0 ) 					#name: #LblPC 					#label: 'PC' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 45 0 187 0 145 0 206 0 ) 					#name: #RegA 					#model: #RegA 					#isReadOnly: true 					#type: #string ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 44 0 213 0 144 0 232 0 ) 					#name: #RegB 					#model: #RegB 					#isReadOnly: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 45 0 239 0 145 0 258 0 ) 					#name: #PC 					#model: #PC 					#isReadOnly: true 					#type: #number ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 137 0 23 0 244 0 44 0 ) 					#name: #ActionButton1 					#model: #Load 					#label: 					#(#{Kernel.UserMessage} 						#key: #LoadintoMemory 						#defaultString: 'Load into Memory' ) 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 293 0 235 0 393 0 254 0 ) 					#name: #overflow 					#model: #overflow 					#isReadOnly: true 					#type: #boolean ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 293 0 255 0 393 0 274 0 ) 					#name: #zero 					#model: #zero 					#isReadOnly: true 					#type: #boolean ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 256 0 53 0 342 0 219 0 ) 					#name: #lstMem 					#model: #lstMem 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 349 0 55 0 435 0 219 0 ) 					#name: #lstSymbol 					#model: #lstSymbol 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 257 0 31 0 ) 					#name: #Label1 					#label: 'Memory' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 349 0 30 0 ) 					#name: #Label2 					#label: 'Symbols' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 260 0 257 0 ) 					#name: #Label3 					#label: 'Zero?' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 236 0 237 0 ) 					#name: #Label4 					#label: 'Overflow?' ) ) ) )</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="AllAction">AllAction	| word aStream inst |		(pc ~= 0)	ifTrue:[		[pc &lt;= 256]		whileTrue:[			word := ali memory at: pc.			(word ~= nil)			ifTrue:[				aStream := word readStream.				inst := aStream upToAll: ' '.				(inst asString = 'HLT')				ifFalse:[					self NextAction.					]				]			]		]	ifFalse:[		self NextAction.		[pc &lt;= 256]		whileTrue:[			word := ali memory at: pc.			(word ~= nil)			ifTrue:[				aStream := word readStream.				inst := aStream upToAll: ' '.				(inst asString = 'HLT')				ifFalse:[					self NextAction.					]				]			]		].			^self</body></methods><do-it>GUI open.</do-it><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="AllAction">AllAction	| word aStream inst |		(pc ~= 0)	ifTrue:[		[pc &lt;= 256]		whileTrue:[			word := ali memory at: pc.			(word ~= nil)			ifTrue:[				aStream := word readStream.				inst := aStream upToAll: ' '.				(inst asString = 'HLT')				ifFalse:[					self NextAction.					].				]			ifFalse:[				pc := pc + 1.				].			]		]	ifFalse:[		self NextAction.		[pc &lt;= 256]		whileTrue:[			word := ali memory at: pc.			(word ~= nil)			ifTrue:[				aStream := word readStream.				inst := aStream upToAll: ' '.				(inst asString = 'HLT')				ifFalse:[					self NextAction.					]				]			]		].			^self</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="AllAction">AllAction	| word aStream inst |		(pc ~= 0)	ifTrue:[		[pc &lt;= 256]		whileTrue:[			word := ali memory at: pc.			(word ~= nil)			ifTrue:[				aStream := word readStream.				inst := aStream upToAll: ' '.				(inst asString = 'HLT')				ifFalse:[					self NextAction.					].				]			ifFalse:[				pc := pc + 1.				PC value: (pc asNumber).				].			]		]	ifFalse:[		self NextAction.		[pc &lt;= 256]		whileTrue:[			word := ali memory at: pc.			(word ~= nil)			ifTrue:[				aStream := word readStream.				inst := aStream upToAll: ' '.				(inst asString = 'HLT')				ifFalse:[					self NextAction.					].				]			ifFalse:[				pc := pc + 1.				PC value: (pc asNumber).				].			]		].			^self</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="AllAction">AllAction	| word aStream inst |		(pc ~= 0)	ifTrue:[		[pc &lt;= 256]		whileTrue:[			word := ali memory at: pc.			(word ~= nil)			ifTrue:[				aStream := word readStream.				inst := aStream upToAll: ' '.				(inst asString = 'HLT')				ifTrue:[					^self.					]				ifFalse:[					self NextAction.					].				]			ifFalse:[				pc := pc + 1.				PC value: (pc asNumber).				].			]		]	ifFalse:[		self NextAction.		[pc &lt;= 256]		whileTrue:[			word := ali memory at: pc.			(word ~= nil)			ifTrue:[				aStream := word readStream.				inst := aStream upToAll: ' '.				(inst asString = 'HLT')				ifTrue:[					^self.					]				ifFalse:[					self NextAction.					].				]			ifFalse:[				pc := pc + 1.				PC value: (pc asNumber).				].			]		].			^self</body></methods><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="AllAction">AllAction	| word aStream inst |		(pc ~= 0)	ifTrue:[		[pc &lt;= 256]		whileTrue:[			word := ali memory at: pc.			(word ~= nil)			ifTrue:[				aStream := word readStream.				inst := aStream upToAll: ' '.				(inst asString = 'HLT')				ifTrue:[					pc := pc + 1.					PC value: (pc asNumber).					^self.					]				ifFalse:[					self NextAction.					].				]			ifFalse:[				pc := pc + 1.				PC value: (pc asNumber).				].			]		]	ifFalse:[		self NextAction.		[pc &lt;= 256]		whileTrue:[			word := ali memory at: pc.			(word ~= nil)			ifTrue:[				aStream := word readStream.				inst := aStream upToAll: ' '.				(inst asString = 'HLT')				ifTrue:[					pc := pc + 1.					PC value: (pc asNumber).					^self.					]				ifFalse:[					self NextAction.					].				]			ifFalse:[				pc := pc + 1.				PC value: (pc asNumber).				].			]		].			^self</body></methods><do-it>GUI open.</do-it><do-it>GUI open.</do-it><methods><class-id>ADD</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGUI		| sum tmpa tmpb rega regb |	tmpa := aGUI RegA value asNumber.	tmpb := aGUI RegB value asNumber.	rega := tmpa asSmallInteger.	regb := tmpb asSmallInteger.	sum := rega + regb.	aGUI ovfValue: false.	aGUI overflow value: false.	aGUI zeroVal: false.	aGUI zero value: false.		(sum &gt; 536870911)	ifTrue: [		aGUI ovfValue: true.		aGUI overflow value: true.].		(sum &lt; -536870912)	ifTrue: [		aGUI ovfValue: true.		aGUI overflow value: true.].		(sum = 0)	ifTrue: [		aGUI zeroVal: true.		aGUI zero value: true.		].		aGUI RegA value: (sum printString).</body></methods><do-it>GUI open.</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('c:\Users\Joey\Documents\VisualWorks Projects\Project2\Project2.im' 'March 18, 2018' '10:27:48 PM')""An image file c:\Users\Joey\Documents\VisualWorks Projects\Project2\Project2.im was created at 10:27:48 PM on March 18, 2018."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('c:\Users\Joey\Documents\VisualWorks Projects\Project2\P2Backup.im' 'March 18, 2018' '10:28:02 PM')""An image file c:\Users\Joey\Documents\VisualWorks Projects\Project2\P2Backup.im was created at 10:28:02 PM on March 18, 2018."</do-it><comment><class-id>ALI</class-id><body>This class holds memory and symbol values as arraysInstance Variables:	memory	&lt;Array&gt;	description of memory	symbols	&lt;Array&gt;	description of symbols</body></comment><comment><class-id>GUI</class-id><body>This class is the main driver behind the program. To begin, instantiate a GUI and pass it "open"Instance Variables:	ali	&lt;ALI&gt;	description of ali	lstMem	&lt;SelectionInList&gt;	description of lstMem	lstSymbol	&lt;SelectionInList&gt;	description of lstSymbol	overflow	&lt;ValueHolder&gt;	description of overflow	ovfValue	&lt;Boolean&gt;	description of ovfValue	pc	&lt;Number&gt;	description of pc	PC	&lt;ValueModel&gt;	description of PC	RegA	&lt;ValueHolder&gt;	description of RegA	RegB	&lt;ValueHolder&gt;	description of RegB	TextAspect	&lt;ValueModel&gt;	description of TextAspect	zero	&lt;ValueHolder&gt;	description of zero	zeroVal	&lt;Boolean&gt;	description of zeroVal</body></comment><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="AllAction">AllAction	| word aStream inst |		"Makes sure you aren't grabbing index 0"	(pc ~= 0)	ifTrue:[		"Iterates through memory"		[pc &lt;= 256]		whileTrue:[			word := ali memory at: pc.			(word ~= nil)			ifTrue:[				aStream := word readStream.				inst := aStream upToAll: ' '.				(inst asString = 'HLT')				ifTrue:[					"If HLT is seen, stop at the line right after"					pc := pc + 1.					PC value: (pc asNumber).					^self.					]				ifFalse:[					"If not HLT, continue executing"					self NextAction.					].				]			ifFalse:[				pc := pc + 1.				PC value: (pc asNumber).				].			]		]	ifFalse:[		self NextAction.		[pc &lt;= 256]		whileTrue:[			word := ali memory at: pc.			(word ~= nil)			ifTrue:[				aStream := word readStream.				inst := aStream upToAll: ' '.				(inst asString = 'HLT')				ifTrue:[					pc := pc + 1.					PC value: (pc asNumber).					^self.					]				ifFalse:[					self NextAction.					].				]			ifFalse:[				pc := pc + 1.				PC value: (pc asNumber).				].			]		].			^self</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="AllAction">AllAction	| word aStream inst |		"Makes sure you aren't grabbing index 0"	(pc ~= 0)	ifTrue:[		"Iterates through memory"		[pc &lt;= 256]		whileTrue:[			word := ali memory at: pc.			(word ~= nil)			ifTrue:[				aStream := word readStream.				inst := aStream upToAll: ' '.				(inst asString = 'HLT')				ifTrue:[					"If HLT is seen, stop at the line right after"					pc := pc + 1.					PC value: (pc asNumber).					^self.					]				ifFalse:[					"If not HLT, continue executing"					self NextAction.					].				]			ifFalse:[				"Continue if memory is nil"				pc := pc + 1.				PC value: (pc asNumber).				].			]		]	ifFalse:[		self NextAction.		[pc &lt;= 256]		whileTrue:[			word := ali memory at: pc.			(word ~= nil)			ifTrue:[				aStream := word readStream.				inst := aStream upToAll: ' '.				(inst asString = 'HLT')				ifTrue:[					"If HLT is seen, stop at the line right after"					pc := pc + 1.					PC value: (pc asNumber).					^self.					]				ifFalse:[					"If not HLT, continue executing"					self NextAction.					].				]			ifFalse:[				"Continue if memory is nil"				pc := pc + 1.				PC value: (pc asNumber).				].			]		].			^self</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="Load">Load	| aStream word index|	"Create new ali and load program into memory"	ali := ALI new.	index := 1.	"Parses Text into memory"	aStream := TextAspect value readStream.	word := (aStream upTo: (Character cr)).	[aStream atEnd] whileFalse: [		ali memory at: index put: word. 		word := (aStream upTo: (Character cr)).		index := index + 1.		].	ali memory at: index put: word.	lstMem list: ali memory.	lstSymbol list: ali symbols.		"Initializers"	pc := 0.	zeroVal := false.	ovfValue := false.		^self</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="AssemblyInterpreter" selector="NextAction">NextAction	| inst val dec lda ldb ldi st xch jmp jzs jvs add hlt word aStream|		"Moves PC ahead and checks each command	Uses specific method depending on commands"		pc := pc + 1.	PC value: (pc asNumber).	((ali memory at: pc) = nil)	ifTrue: [^ self].		word := ali memory at: pc.	aStream := word readStream.	inst := aStream upToAll: ' '.		((inst asString) = 'DEC') 	ifTrue:[	aStream next.	val := aStream upToEnd.	dec := DEC new.	dec value: val.	dec command: self.	].	((inst asString) = 'LDA') 	ifTrue:[	aStream next.	val := aStream upToEnd.	lda := LDA new.	lda value: val.	lda command: self.	].	((inst asString) = 'LDB') 	ifTrue:[	aStream next.	val := aStream upToEnd.	ldb := LDB new.	ldb value: val.	ldb command: self.	].		((inst asString) = 'LDI') 	ifTrue:[	aStream next.	val := aStream upToEnd.	ldi := LDI new.	ldi value: val.	ldi command: self.	].	((inst asString) = 'ST') 	ifTrue:[	aStream next.	val := aStream upToEnd.	st := ST new.	st value: val.	st command: self.	].	((inst asString) = 'XCH') 	ifTrue:[	xch := XCH new.	xch command: self.	].	((inst asString) = 'JMP') 	ifTrue:[	aStream next.	val := aStream upToEnd.	jmp := JMP new.	jmp value: val.	jmp command: self.	].	((inst asString) = 'JZS') 	ifTrue:[	aStream next.	val := aStream upToEnd.	jzs := JZS new.	jzs value: val.	jzs command: self.	].	((inst asString) = 'JVS') 	ifTrue:[	aStream next.	val := aStream upToEnd.	jvs := JVS new.	jvs value: val.	jvs command: self.	].	((inst asString) = 'ADD') 	ifTrue:[	add := ADD new.	add command: self.	].	((inst asString) = 'HLT') 	ifTrue:[	hlt := HLT new.	hlt command: self.	].		^self</body></methods><comment><class-id>SAL</class-id><body>Parent class of instructionsSubclasses must implement the following messages:	command		command:</body></comment><comment><class-id>ADD</class-id><body>Adds RegA to RegB and displays in RegA. Also sets Overflow and Zero bits</body></comment><methods><class-id>ADD</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGUI		"Grabs variables"	| sum tmpa tmpb rega regb |	tmpa := aGUI RegA value asNumber.	tmpb := aGUI RegB value asNumber.	rega := tmpa asSmallInteger.	regb := tmpb asSmallInteger.	sum := rega + regb.	aGUI ovfValue: false.	aGUI overflow value: false.	aGUI zeroVal: false.	aGUI zero value: false.		"Overflow?"	(sum &gt; 536870911)	ifTrue: [		aGUI ovfValue: true.		aGUI overflow value: true.].		"Overflow?"	(sum &lt; -536870912)	ifTrue: [		aGUI ovfValue: true.		aGUI overflow value: true.].		"Zero?"	(sum = 0)	ifTrue: [		aGUI zeroVal: true.		aGUI zero value: true.		].		aGUI RegA value: (sum printString).</body></methods><comment><class-id>DEC</class-id><body>Creates a symbolInstance Variables:	value	&lt;MessageForwarder | Object | ProtoObject | ProtoObject&gt;	description of value</body></comment><methods><class-id>DEC</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGui	"Loads symbol into symbol table"	aGui ali symbols at: (aGui pc) put: value.</body></methods><methods><class-id>DEC</class-id> <category>accessing</category><body package="AssemblyInterpreter" selector="value:">value: aSymbol	value := aSymbol.</body></methods><methods><class-id>DEC</class-id> <category>accessing</category><body package="AssemblyInterpreter" selector="value:">value: aSymbol	value := aSymbol</body></methods><comment><class-id>HLT</class-id><body>Halts program to stop</body></comment><methods><class-id>HLT</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGUI	"The only command that does not implement because of the way I chose to implement it"	^self shouldNotImplement</body></methods><comment><class-id>JMP</class-id><body>Jumps to memory locationInstance Variables:	value	&lt;CharacterArray | Number&gt;	description of value</body></comment><methods><class-id>JMP</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGUI	"Gathers pc info and jumps to that location in memory"	aGUI pc: (value asNumber).	aGUI PC value: (aGUI pc asNumber).</body></methods><comment><class-id>JVS</class-id><body>Jumps to memory location if overflow bit is true.Instance Variables:	value	&lt;CharacterArray | Number&gt;	description of value</body></comment><comment><class-id>JVS</class-id><body>Jumps to memory location if overflow bit is trueInstance Variables:	value	&lt;CharacterArray | Number&gt;	description of value</body></comment><methods><class-id>JVS</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGUI	"Checks if overflowed, if so then jump to memory location given"	(aGUI ovfValue = true)	ifTrue:[		aGUI pc: (value asNumber).		aGUI PC value: (aGUI pc asNumber).		]</body></methods><methods><class-id>JZS</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGUI	"Checks if zero sum, if so then jump to memory location given"	(aGUI zeroVal = true)	ifTrue:[		aGUI pc: (value asNumber).		aGUI PC value: (aGUI pc asNumber).		]</body></methods><comment><class-id>JZS</class-id><body>Jumps to memory location if zero bit is set to trueInstance Variables:	value	&lt;CharacterArray | Number&gt;	description of value</body></comment><comment><class-id>LDA</class-id><body>Loads memory location at symbol into RegAInstance Variables:	value	&lt;MessageForwarder | Object | ProtoObject | ProtoObject&gt;	description of value</body></comment><methods><class-id>LDA</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGUI		| index|		"Iterates through symbol array for index.	Uses index to store value at memory location into RegA"	index := 1.	[index &lt;= 256]	whileTrue:[		((aGUI ali symbols at: index) = value)		ifTrue: [aGUI RegA value: (aGUI ali memory at: index)].		index := index + 1.		]</body></methods><methods><class-id>LDB</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGUI		| index|		"Iterates through symbol array for index.	Uses index to store value at memory location into RegB"	index := 1.	[index &lt;= 256]	whileTrue:[		((aGUI ali symbols at: index) = value)		ifTrue: [aGUI RegB value: (aGUI ali memory at: index)].		index := index + 1.		]</body></methods><comment><class-id>LDB</class-id><body>Loads memory location at symbol into RegAInstance Variables:	value	&lt;MessageForwarder | Object | ProtoObject | ProtoObject&gt;	description of value</body></comment><comment><class-id>LDB</class-id><body>Loads memory location at symbol into RegBInstance Variables:	value	&lt;MessageForwarder | Object | ProtoObject | ProtoObject&gt;	description of value</body></comment><comment><class-id>LDI</class-id><body>Loads value into RegAInstance Variables:	value	&lt;MessageForwarder | Object | ProtoObject | ProtoObject&gt;	description of value</body></comment><methods><class-id>LDI</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGui	"Loads value into RegA"	aGui RegA value: value.</body></methods><methods><class-id>ST</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGUI		| index|		"Iterates through symbol table to find index.	Stores at memory index the value in RegA."	index := 1.	[index &lt;= 256]	whileTrue:[		((aGUI ali symbols at: index) = value)		ifTrue: [aGUI ali memory at: index put: (aGUI RegA value)].		index := index + 1.		]</body></methods><comment><class-id>ST</class-id><body>Loads RegA into memory at the location of the symbolInstance Variables:	value	&lt;MessageForwarder | Object | ProtoObject | ProtoObject&gt;	description of value</body></comment><comment><class-id>XCH</class-id><body>Exchanges values of RegA and RegB</body></comment><methods><class-id>XCH</class-id> <category>command</category><body package="AssemblyInterpreter" selector="command:">command: aGUI		| temp |		"Exchanges values of RegA and RegB"	temp := aGUI RegA value.	aGUI RegA value: (aGUI RegB value).	aGUI RegB value: temp.</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('c:\Users\Joey\Documents\VisualWorks Projects\Project2\Project2.im' 'March 18, 2018' '11:00:35 PM')""An image file c:\Users\Joey\Documents\VisualWorks Projects\Project2\Project2.im was created at 11:00:35 PM on March 18, 2018."</do-it><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>SortedDictionary</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>SortedDictionary</staticKey> <definitionChange>added</definitionChange></component_static_change><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>TreeDictionaryNode</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>TreeDictionaryNode</staticKey> <definitionChange>added</definitionChange></component_static_change><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>DictionaryPair</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>DictionaryPair</staticKey> <definitionChange>added</definitionChange></component_static_change><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>NewDictionaryGUI</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>NewDictionaryGUI</staticKey> <definitionChange>added</definitionChange></component_static_change><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>TreeDictionary</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>TreeDictionary</staticKey> <definitionChange>added</definitionChange></component_static_change><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>NewDictionary</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>NewDictionary</staticKey> <definitionChange>added</definitionChange></component_static_change><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>BST</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>BST</staticKey> <definitionChange>added</definitionChange></component_static_change><component-rename><name>AssemblyInterpreter</name> <type>package</type><newName>CS474</newName></component-rename><component-property><name>CS474</name> <type>package</type><property>packageName</property> <value>'CS474'</value></component-property><do-it>'----SNAPSHOT----'</do-it><do-it>"#('c:\Users\Joey\Documents\VisualWorks Projects\Project2\Project2.im' 'March 18, 2018' '11:02:51 PM')""An image file c:\Users\Joey\Documents\VisualWorks Projects\Project2\Project2.im was created at 11:02:51 PM on March 18, 2018."</do-it><do-it>GUI open.</do-it><methods><class-id>GUI</class-id> <category>actions</category><body package="CS474" selector="NextAction">NextAction	| inst val dec lda ldb ldi st xch jmp jzs jvs add hlt word aStream|		"Moves PC ahead and checks each command	Uses specific method depending on commands"		pc := pc + 1.	PC value: (pc asNumber).	((ali memory at: pc) = nil)	ifTrue: [^ self].		word := ali memory at: pc.	aStream := word readStream.	inst := aStream upToAll: ' '.		((inst asString) = 'DEC') 	ifTrue:[	aStream next.	val := aStream upToEnd.	dec := DEC new.	dec value: val.	dec command: self.	].	((inst asString) = 'LDA') 	ifTrue:[	aStream next.	val := aStream upToEnd.	lda := LDA new.	lda value: val.	lda command: self.	].	((inst asString) = 'LDB') 	ifTrue:[	aStream next.	val := aStream upToEnd.	ldb := LDB new.	ldb value: val.	ldb command: self.	].		((inst asString) = 'LDI') 	ifTrue:[	aStream next.	val := aStream upToEnd.	ldi := LDI new.	ldi value: val.	ldi command: self.	].	((inst asString) = 'ST') 	ifTrue:[	aStream next.	val := aStream upToEnd.	st := ST new.	st value: val.	st command: self.	].	((inst asString) = 'XCH') 	ifTrue:[	xch := XCH new.	xch command: self.	].	((inst asString) = 'JMP') 	ifTrue:[	aStream next.	val := aStream upToEnd.	jmp := JMP new.	jmp value: val.	jmp command: self.	].	((inst asString) = 'JZS') 	ifTrue:[	aStream next.	val := aStream upToEnd.	jzs := JZS new.	jzs value: val.	jzs command: self.	].	((inst asString) = 'JVS') 	ifTrue:[	aStream next.	val := aStream upToEnd.	jvs := JVS new.	jvs value: val.	jvs command: self.	].	((inst asString) = 'ADD') 	ifTrue:[	add := ADD new.	add command: self.	].		^self</body></methods><methods><class-id>GUI</class-id> <category>actions</category><body package="CS474" selector="NextAction">NextAction	| inst val dec lda ldb ldi st xch jmp jzs jvs add word aStream|		"Moves PC ahead and checks each command	Uses specific method depending on commands"		pc := pc + 1.	PC value: (pc asNumber).	((ali memory at: pc) = nil)	ifTrue: [^ self].		word := ali memory at: pc.	aStream := word readStream.	inst := aStream upToAll: ' '.		((inst asString) = 'DEC') 	ifTrue:[	aStream next.	val := aStream upToEnd.	dec := DEC new.	dec value: val.	dec command: self.	].	((inst asString) = 'LDA') 	ifTrue:[	aStream next.	val := aStream upToEnd.	lda := LDA new.	lda value: val.	lda command: self.	].	((inst asString) = 'LDB') 	ifTrue:[	aStream next.	val := aStream upToEnd.	ldb := LDB new.	ldb value: val.	ldb command: self.	].		((inst asString) = 'LDI') 	ifTrue:[	aStream next.	val := aStream upToEnd.	ldi := LDI new.	ldi value: val.	ldi command: self.	].	((inst asString) = 'ST') 	ifTrue:[	aStream next.	val := aStream upToEnd.	st := ST new.	st value: val.	st command: self.	].	((inst asString) = 'XCH') 	ifTrue:[	xch := XCH new.	xch command: self.	].	((inst asString) = 'JMP') 	ifTrue:[	aStream next.	val := aStream upToEnd.	jmp := JMP new.	jmp value: val.	jmp command: self.	].	((inst asString) = 'JZS') 	ifTrue:[	aStream next.	val := aStream upToEnd.	jzs := JZS new.	jzs value: val.	jzs command: self.	].	((inst asString) = 'JVS') 	ifTrue:[	aStream next.	val := aStream upToEnd.	jvs := JVS new.	jvs value: val.	jvs command: self.	].	((inst asString) = 'ADD') 	ifTrue:[	add := ADD new.	add command: self.	].		^self</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('c:\Users\Joey\Documents\VisualWorks Projects\Project2\Project2.im' 'March 18, 2018' '11:05:31 PM')""An image file c:\Users\Joey\Documents\VisualWorks Projects\Project2\Project2.im was created at 11:05:31 PM on March 18, 2018."</do-it><do-it>GUI open.</do-it><do-it>GUI open.</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('c:\Users\Joey\Documents\VisualWorks Projects\Project2\Project2.im' 'March 18, 2018' '11:07:53 PM')""An image file c:\Users\Joey\Documents\VisualWorks Projects\Project2\Project2.im was created at 11:07:53 PM on March 18, 2018."</do-it><methods><class-id>SAL</class-id> <category>command</category><body package="CS474" selector="execute">execute	^self subclassResponsibility</body></methods><remove-selector><class-id>SAL</class-id> <selector>execute</selector></remove-selector><component-rename><name>CS474</name> <type>package</type><newName>Assembly-Interpreter</newName></component-rename><component-property><name>Assembly-Interpreter</name> <type>package</type><property>packageName</property> <value>'Assembly-Interpreter'</value></component-property><do-it>'----SNAPSHOT----'</do-it><do-it>"#('c:\Users\Joey\Documents\474\Project2\Project2.im' 'April 5, 2018' '11:03:04 AM')""An image file c:\Users\Joey\Documents\474\Project2\Project2.im was created at 11:03:04 AM on April 5, 2018."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('c:\Users\Joey\Documents\474\Project2\Project2.im' 'April 5, 2018' '11:03:14 AM')""An image file c:\Users\Joey\Documents\474\Project2\Project2.im was created at 11:03:14 AM on April 5, 2018."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('c:\Users\Joey\Documents\474\Project2\Assembly-Interpreter\Assembly-Interpreter-Image.im' 'April 5, 2018' '11:05:51 AM')""An image file c:\Users\Joey\Documents\474\Project2\Assembly-Interpreter\Assembly-Interpreter-Image.im was created at 11:05:51 AM on April 5, 2018."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('c:\Users\Joey\Documents\474\Project2\Assembly-Interpreter\Assembly-Interpreter-Image.im' 'April 5, 2018' '11:05:58 AM')""An image file c:\Users\Joey\Documents\474\Project2\Assembly-Interpreter\Assembly-Interpreter-Image.im was created at 11:05:58 AM on April 5, 2018."</do-it>